<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++学习 | 木风可可</title><meta name="keywords" content="学习笔记,C++"><meta name="author" content="秋山澪"><meta name="copyright" content="秋山澪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="vs注释快捷键添加注释快捷键:ctrl + k· + c取出注释快捷键:ctrl + k + u代码补全快捷键:ctrl + j  数据的输出:coutcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;	&#x2F;&#x2F;加了&lt;&lt; endl 表示换行，不加就不换行   定义常量1、#define i 102、const int i &#x3D; 1">
<meta property="og:type" content="article">
<meta property="og:title" content="C++学习">
<meta property="og:url" content="http://example.com/c++note/index.html">
<meta property="og:site_name" content="木风可可">
<meta property="og:description" content="vs注释快捷键添加注释快捷键:ctrl + k· + c取出注释快捷键:ctrl + k + u代码补全快捷键:ctrl + j  数据的输出:coutcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;	&#x2F;&#x2F;加了&lt;&lt; endl 表示换行，不加就不换行   定义常量1、#define i 102、const int i &#x3D; 1">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yanxuan.nosdn.127.net/27ad4240afb3fa07197eaec257022c89.jpg">
<meta property="article:published_time" content="2020-04-03T02:14:52.000Z">
<meta property="article:modified_time" content="2020-11-10T11:28:05.843Z">
<meta property="article:author" content="秋山澪">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yanxuan.nosdn.127.net/27ad4240afb3fa07197eaec257022c89.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/c++note/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-11-10 19:28:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s1.ax1x.com/2020/10/17/0LTXFK.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://yanxuan.nosdn.127.net/27ad4240afb3fa07197eaec257022c89.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">木风可可</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-04-03T02:14:52.000Z" title="发表于 2020-04-03 10:14:52">2020-04-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-11-10T11:28:05.843Z" title="更新于 2020-11-10 19:28:05">2020-11-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="vs注释快捷键"><a href="#vs注释快捷键" class="headerlink" title="vs注释快捷键"></a>vs注释快捷键</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">添加注释快捷键:ctrl + k· + c</span><br><span class="line"></span><br><span class="line">取出注释快捷键:ctrl + k + u</span><br><span class="line"></span><br><span class="line">代码补全快捷键:ctrl + j</span><br></pre></td></tr></table></figure>

<h1 id="数据的输出-cout"><a href="#数据的输出-cout" class="headerlink" title="数据的输出:cout"></a>数据的输出:cout</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; <span class="string">a &lt;&lt; endl;	//加了&lt;&lt; endl 表示换行，不加就不换行</span></span><br></pre></td></tr></table></figure>


<h1 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、<span class="comment">#define i 10</span></span><br><span class="line">2、const int i = 10；//常量不可被修改</span><br></pre></td></tr></table></figure>

<h1 id="sizeof-统计数据类型所占的内存大小"><a href="#sizeof-统计数据类型所占的内存大小" class="headerlink" title="sizeof 统计数据类型所占的内存大小"></a>sizeof 统计数据类型所占的内存大小</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sizeof (数据类型/变量)</span><br></pre></td></tr></table></figure>


<h1 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">short		2字节</span><br><span class="line">int			4字节</span><br><span class="line">long		4字节</span><br><span class="line">long long	8字节</span><br></pre></td></tr></table></figure>

<h1 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">double （不用加表示）		8字节</span><br><span class="line"><span class="built_in">float</span> f1 = 3.14f（加f）	4字节</span><br></pre></td></tr></table></figure>

<h1 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.char str[] = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">2.string str = <span class="string">&quot;Hello World&quot;</span>	使用时要<span class="comment">#include &lt;string&gt;</span></span><br><span class="line">string类型可以装中文	</span><br></pre></td></tr></table></figure>

<h1 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bool	1字节</span><br><span class="line">布尔类型只要非0，都代表真</span><br></pre></td></tr></table></figure>

<h1 id="科学计数法"><a href="#科学计数法" class="headerlink" title="科学计数法"></a>科学计数法</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">e后为正	3e2 : 	3 * (10 ^ 2)</span><br><span class="line">e后为负	3e-2: 	3 * (0.1 ^2)</span><br></pre></td></tr></table></figure>

<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\n:换行</span><br><span class="line">\t:跳到下一个tab位置（可以对齐\t后面的字符）</span><br><span class="line">\\:代表一个“\”</span><br><span class="line">\?:代表一个“?”</span><br></pre></td></tr></table></figure>

<h1 id="数据的输入-cin"><a href="#数据的输入-cin" class="headerlink" title="数据的输入:cin"></a>数据的输入:cin</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; a</span><br></pre></td></tr></table></figure>

<h1 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句:"></a>跳转语句:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">break</span>	跳出当前循环，并终止循环</span><br><span class="line">contrue	结束此次循环，继续下一次循环</span><br><span class="line">goto	无条件跳转语句</span><br><span class="line">goto使用:	goto FLAG;（前往标记的那一行，FLAG可以随便取）</span><br><span class="line">FLAG:（冒号表示这是个标记）</span><br></pre></td></tr></table></figure>

<h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件:"></a>头文件:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &quot;hello.h&quot;	用双引号，表示是自己自定义的头文件</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;	这两句写在头文件中，源文件中只要包含“Hello.h”就行了</span><br><span class="line">		</span><br><span class="line">c++里不用写<span class="comment">#ifndef #define    #endif	并不会报警告</span></span><br><span class="line">并且头文件中不用再包含自身的头文件</span><br></pre></td></tr></table></figure>

<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">定义: int * a	32位系统4字节</span><br><span class="line">			64位系统8字节（在上方的解决方案列表中可以修改系统位数）</span><br><span class="line">	指针前加一个*，代表解引用，指向指针所指向的内存</span><br><span class="line">	</span><br><span class="line">空指针指向的内存是不允许进行操作的:int * p = NULL	不能直接访问 *p</span><br></pre></td></tr></table></figure>
<h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针:"></a>野指针:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int * p =  (int *)0x1100 	指针变量指向非法的内存空间</span><br></pre></td></tr></table></figure>

<h2 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针:"></a>常量指针:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const int * p	（const修饰的是*p，所以指向的值不能修改，但可以直接对内存进行修改，例直接改a:a = 20）</span><br></pre></td></tr></table></figure>

<h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量:"></a>指针常量:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int * const p	（const指向的是指针变量，所以p的指向不能修改）</span><br><span class="line">指针的指向不可以改，但指向的值可以修改		</span><br><span class="line"></span><br><span class="line">int * const p = &amp;a;	*p = 20;(<span class="literal">true</span>)	p = &amp;b;(error)</span><br></pre></td></tr></table></figure>

<h2 id="指针指向数组"><a href="#指针指向数组" class="headerlink" title="指针指向数组:"></a>指针指向数组:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int * p = arr;	数组的名字就是数组的首地址</span><br></pre></td></tr></table></figure>


<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体:"></a>结构体:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">定义	:</span><br><span class="line">struct st &#123;</span><br><span class="line">			string name;</span><br><span class="line">			int age;</span><br><span class="line">	      &#125;;</span><br><span class="line"></span><br><span class="line">创建:	struct st st1 = &#123;<span class="string">&quot;zhangsan&quot;</span>,18&#125;;</span><br><span class="line"></span><br><span class="line">结构体数组:struct st starr[2] = &#123;</span><br><span class="line">				&#123;<span class="string">&quot;zhangsan&quot;</span>,20&#125;,</span><br><span class="line">				&#123;<span class="string">&quot;lisi&quot;</span>,10&#125;</span><br><span class="line">				&#125;;	</span><br><span class="line">结构体数组的访问:starr[1].name = <span class="string">&quot;wangwu&quot;</span>;</span><br><span class="line"></span><br><span class="line">结构体指针:要用-&gt;</span><br><span class="line">	struct st st1 = &#123;<span class="string">&quot;zhangsan&quot;</span>,20&#125;;</span><br><span class="line">	</span><br><span class="line">	struct st * p = &amp;st1;通过指针指向结构体</span><br><span class="line">	访问:p-&gt;name = <span class="string">&quot;zhaoliu&quot;</span>;	用-&gt;来访问成员，p前面不用加*，直接用指针指向成员就行了</span><br><span class="line"></span><br><span class="line">const修饰结构体:const struct st st1	防止误操作</span><br></pre></td></tr></table></figure>

<h1 id="system命令"><a href="#system命令" class="headerlink" title="system命令:"></a>system命令:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">system(<span class="string">&quot;pause&quot;</span>):	按任意键继续</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);	清屏</span><br></pre></td></tr></table></figure>

<h1 id="四个分区"><a href="#四个分区" class="headerlink" title="四个分区:"></a>四个分区:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">代码区:	代码区是共享的（只存在一份文件，而多个进程共享使用）</span><br><span class="line">		代码区是只读的（防止程序被意外修改）</span><br><span class="line">全局区:	存放全局变量、静态变量以及常量</span><br><span class="line">		该区域的数据在结束后有操作系统释放</span><br><span class="line">		静态变量:static int i = 10	在局部变量前加static</span><br><span class="line">		常量:分为字符串常量和const修饰的变量</span><br><span class="line">				const修饰的变量:	const修饰的全局变量</span><br><span class="line">				const修饰的局部变量（不在全局区）		</span><br><span class="line">栈区:	由编译器管理开辟和释放（指针也是局部变量，存放在栈区）</span><br><span class="line">		局部变量存放在栈区，不要返回局部变量的地址（因为语句执行完后，局部变量对应内存会被编译器自动释放）</span><br><span class="line">堆区:	由程序员分配释放，若不释放，程序结束后有操作系统回收</span><br><span class="line">		用new可以在堆区开辟内存，释放用delete</span><br><span class="line">		int * p = new int(10);（会返回指针，则用指针变量来接收）	 </span><br></pre></td></tr></table></figure>

<h1 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字:"></a>new关键字:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int * p = new int(10);	新建一个对象</span><br><span class="line">delete p；			释放该堆区的内存</span><br><span class="line">int * arr = new int[10]	new开辟数组</span><br><span class="line"></span><br><span class="line">可以直接arr[]加下标使用数据</span><br><span class="line">delete[] arr;		释放数组要加上[]</span><br></pre></td></tr></table></figure>

<h1 id="引用"><a href="#引用" class="headerlink" title="引用:"></a>引用:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">作用:给变量取别名</span><br><span class="line">本质:引用本质是一个指针常量</span><br><span class="line">语法:数据类型 &amp;别名 = 原名</span><br><span class="line">例:	int a = 10;</span><br><span class="line">	int &amp;b = a;	给a取了个别名叫b，修改时a与b修改的是同一块内存</span><br><span class="line">注意事项:1、引用必须初始化（例int &amp;b错误，要初始化）</span><br><span class="line">	2、引用在初始化后就不能改变了</span><br><span class="line">	错误:	int &amp;b = a;int &amp;b = c;不能指向a后再改变为指向c；	 </span><br><span class="line">引用作为函数形参:</span><br><span class="line">例:	void exchange3(int &amp;a, int &amp;b) &#123;</span><br><span class="line">		int temp;</span><br><span class="line">		temp = a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	调用exchange3(a,b)即可以互换a，b的值，因为形参定义的引用分别指向了a与b，互换引用即可互换对应内存的值</span><br><span class="line">引用作为函数返回值:</span><br><span class="line">	1、不要返回局部变量的引用（加上static就可以了）</span><br><span class="line">		因为局部变量会被系统释放掉，那么它的引用自然也没了意义，会产能为垃圾值</span><br><span class="line">	2、函数的调用可以作为左值</span><br><span class="line">		例:因为返回的是一个引用类型，直接指向static a = 10； 可以只接改变它进行数据的操作，也可以创建另一个引用来引用它，就说明可以进行多重引用</span><br><span class="line">		int&amp; <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">			static int a = 10;</span><br><span class="line">			<span class="built_in">return</span> a;</span><br><span class="line">		&#125;</span><br><span class="line">		int &amp;b = f();把一个引用类型的返回值赋给另一个引用类型，和下面一样是多重引用</span><br><span class="line">		int &amp;c = b;				</span><br><span class="line">		f() = 50;	   直接对引用类型的返回值进行赋值操作，从而改变内存中值的大小	</span><br><span class="line">常量引用:主要用来修饰形参防止误操作</span><br><span class="line">	const int &amp; ref = 10	加入const之后变为只读状态，防止误操作</span><br><span class="line">	防止误操作如下:</span><br><span class="line">	void showValue(const int &amp; val) &#123;</span><br><span class="line">		val = 1000；//error，加了const之后便不能对val进行修改了，从而防止误操作</span><br><span class="line">		cout &lt;&lt; <span class="string">val &lt;&lt; endl;</span></span><br><span class="line"><span class="string">	&#125;	</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数:"></a>函数:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">c++中函数的形参可以给默认值</span><br><span class="line">	如果调用时没传参数，那么就使用默认值</span><br><span class="line">	注意事项:1、如果某个位置有了默认参数，那么从这个位置往右都要有默认参数</span><br><span class="line">			2、如果函数的申明里有了默认参数，那么函数的实现就不能有默认参数		</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数:"></a>函数占位参数:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、只写数据类型，而没写形参	void func(int) &#123;......&#125;	</span><br><span class="line">2、占位参数也可以有默认参数	void func(int = 10) &#123;......&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载:"></a>函数重载:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">可以让函数名相同，提高函数的复用性</span><br><span class="line">满足条件:1、在同一个作用域下</span><br><span class="line">	2、函数名称相同</span><br><span class="line">	3、函数的参数类型不同，或个数不同，或顺序不同</span><br><span class="line">注意事项:1、引用作为函数重载条件（以下两个函数是可以构成函数重载的）</span><br><span class="line">		void func(int &amp;a) &#123;&#125;		fun(a)	调用时传入一个变量</span><br><span class="line">		void func(const int &amp;a) &#123;&#125; 	fun(10)	调用时传入一个常量，构成了引用常量	const int &amp;a = 10	合法的代码，所以才能成功</span><br><span class="line">		2、函数重载碰到默认参数</span><br><span class="line">		void func(int a) &#123;&#125;		如果调用时写func(10)那么会出现二义性，两个函数都能访问，所以出错</span><br><span class="line">		void func(int a, int b = 10) &#123;&#125;	但是写func(10,20)就是没问题的，明确传入有两个形参的函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="封装"><a href="#封装" class="headerlink" title="封装:"></a>封装:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Yuan &#123;</span><br><span class="line">	</span><br><span class="line">	public:		//权限</span><br><span class="line">		int r;	//属性</span><br><span class="line">	public:</span><br><span class="line">		double c;</span><br><span class="line">	//行为</span><br><span class="line">		double <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">			<span class="built_in">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	访问:	1、Yuan y;	定义一个对象</span><br><span class="line">			2、y.r= 10; 	访问属性</span><br><span class="line">			3、y.f()		访问函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="封装的访问权限"><a href="#封装的访问权限" class="headerlink" title="封装的访问权限:"></a>封装的访问权限:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public	公共的	成员类内可以访问，类外可以访问</span><br><span class="line">protected	受保护的	成员类内可以访问，类外不可以访问，继承时可以访问</span><br><span class="line">private	私有的	成员类内可以访问，类外不可以访问，继承时不可以访问</span><br></pre></td></tr></table></figure>

<h1 id="在c-中struct与class的区别"><a href="#在c-中struct与class的区别" class="headerlink" title="在c++中struct与class的区别"></a>在c++中struct与class的区别</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、struct 	默认权限为公有</span><br><span class="line">2、class 	默认权限为私有</span><br><span class="line">权限是类内成员的权限，而不是类的权限</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="构造函数（初始化）"><a href="#构造函数（初始化）" class="headerlink" title="构造函数（初始化）:"></a>构造函数（初始化）:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">创建对象时对对象的成员属性赋值</span><br><span class="line">没有返回值，不写返回值	类名() &#123;&#125;	</span><br></pre></td></tr></table></figure>

<h1 id="析构函数（清理）"><a href="#析构函数（清理）" class="headerlink" title="析构函数（清理）:"></a>析构函数（清理）:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在对象销毁前系统自动调用	</span><br><span class="line">	没有返回值，不写返回值	~类名() &#123;&#125;</span><br><span class="line">	析构函数不可以有参数，因此不能发生函数重载</span><br><span class="line">	系统会自动调用，无需手动调用，而且只会调用一次</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数:"></a>拷贝构造函数:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Person(const Person &amp;p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="构造函数的调用"><a href="#构造函数的调用" class="headerlink" title="构造函数的调用:"></a>构造函数的调用:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、括号法</span><br><span class="line">			Person p;		无参构造函数的调用（注意调用无参构造函数时不要写括号）</span><br><span class="line">			Person p1(10);	有参构造函数的调用</span><br><span class="line">			Person p2(p1);	拷贝构造函数的调用</span><br><span class="line">2、显示法</span><br><span class="line">			Person p1 = Person(10);</span><br><span class="line">			注意:Person(p1)	//error	不要利用拷贝构造函数，初始化匿名对象</span><br><span class="line">3、隐式转换法</span><br><span class="line">			Person p3 = 10;	//相当于Person p3 = Person(10)</span><br><span class="line">			Person p4 = p3;	//隐式转换法的拷贝构造函数的调用</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="拷贝构造函数的使用时机"><a href="#拷贝构造函数的使用时机" class="headerlink" title="拷贝构造函数的使用时机:"></a>拷贝构造函数的使用时机:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、使用一个已经构建完毕的对象来初始化一个新对象</span><br><span class="line">	Person p1(10);	Person p2(p1)	拷贝p1里的内容来初始化自己</span><br><span class="line">2、值传递的方式来给函数参数传值</span><br><span class="line">	void f(Person p) &#123;&#125;</span><br><span class="line">	Person p;	f(p);	在把p传给函数f的形参时会默认调用拷贝构造函数来创建一个副本，原来的p便不会受影响</span><br><span class="line">3、值方式返回局部对象</span><br><span class="line">	Person <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">		Person p;</span><br><span class="line">		<span class="built_in">return</span> p;	返回局部对象会返回一个拷贝的副本，则会调用一个拷贝构造函数</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则:"></a>构造函数调用规则:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">c++会默认给一个类添加三个函数:默认构造函数（空实现），默认析构函数（空实现），默认拷贝构造函数（值拷贝）</span><br><span class="line">如果自定义有参构造函数，则系统不会提供默认无参构造函数，但会提供默认拷贝函数</span><br><span class="line">如果用户自定义拷贝构造函数，那么系统则不会提供其他构造函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝:"></a>深拷贝与浅拷贝:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">浅拷贝:简单的复制拷贝操作</span><br><span class="line">	编译器为我们做的是浅拷贝，简单的赋值操作 age = p.age</span><br><span class="line">	浅拷贝带来的问题:堆区的内存重复释放</span><br><span class="line">深拷贝:在堆区重新申请空间，进行拷贝操作</span><br><span class="line">	例:解决重复释放的问题，用深拷贝来解决浅拷贝的问题</span><br><span class="line">	自己实现拷贝构造函数:m_Height = new int(*p.m_Height);	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表:"></a>初始化列表:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	语法:	Person(int a, int b, int c):m_A(a),m_B(b),m_C(c) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	等价于（用来代替等号赋值）</span><br><span class="line">		Person(int a, int b, int c) &#123;</span><br><span class="line">			m_A = a;</span><br><span class="line">			m_B = b;</span><br><span class="line">			m_C = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员:"></a>类对象作为类成员:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line">class B &#123;</span><br><span class="line">	A a;</span><br><span class="line">&#125;</span><br><span class="line">会先构造类内的对象a，再构造自身B</span><br><span class="line">先析构自身b，再析构类内对象a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员:"></a>静态成员:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">静态成员变量:	1、所有对象共享一份数据</span><br><span class="line">				2、在编译阶段分配内存</span><br><span class="line">				3、类内声明，类外初始化</span><br><span class="line">静态成员函数:	1、所有对象共享一个函数</span><br><span class="line">				2、静态成员函数只能访问静态成员变量，不能访问非静态成员变量</span><br><span class="line"></span><br><span class="line">调用方法:		1、通过对象访问	p.func()</span><br><span class="line">				2、通过类名访问	Person::func()</span><br><span class="line">类内声明类外初始化:</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	static int a;	//类内声明</span><br><span class="line">&#125;</span><br><span class="line">int Person::a = 0;		//类外初始化</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针:"></a>this指针:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">this指针指向被调用的成员函数所属的对象</span><br><span class="line">用途:	1、区分同名的形参与成员变量，this指针和java一个写法:this-&gt;name = name;	指针要用  -&gt; 而不是用   .  </span><br><span class="line">		2、在类的非静态成员中返回对象本身时，可以使用<span class="built_in">return</span> *this</span><br><span class="line">		例:	Person &#123;</span><br><span class="line">				Person&amp; <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">					this-&gt;age += age;</span><br><span class="line">					<span class="built_in">return</span> *this;							&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;	</span><br><span class="line">			调用时可以Person p1;</span><br><span class="line">			p1.func().func().func();	链式调用，因为返回值是当前的对象，调用函数结束后p1.func()还是一个对象，就可以再次调用函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="空指针调用成员函数"><a href="#空指针调用成员函数" class="headerlink" title="空指针调用成员函数:"></a>空指针调用成员函数:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">可以调用没有访问任一属性的函数</span><br></pre></td></tr></table></figure>

<h1 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数:"></a>const修饰成员函数:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、const修饰成员函数称为常函数	void f() const &#123;&#125;</span><br><span class="line">2、常函数内不可以修改成员属性</span><br><span class="line">3、成员属性声明加了关键字mutable后，在常函数中就可以修改</span><br><span class="line">4、声明对象前加const称为常对象	const Person p;</span><br><span class="line">5、常对象只能调用常函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="友元"><a href="#友元" class="headerlink" title="友元:"></a>友元:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">关键字friend，让一个函数或类，能够访问另一个类内的私有成员</span><br><span class="line">	1、全局函数做友元</span><br><span class="line">		语法:将想要去访问的函数声明加上friend写在被访问的类内最前面</span><br><span class="line">		例:friend void goodFriend(Building *building);	写在class Building类下的第一行，将goodFriend函数作为了友元</span><br><span class="line">	2、类做友元</span><br><span class="line">		例:friend class goodGay;	写在被访问Building类的第一行，写一个想要访问的goodGay类的声明</span><br><span class="line">	3、成员函数做友元:</span><br><span class="line">		例:friend void goodGay::visit();	要写成员函数对应的类名</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载:"></a>运算符重载:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">对已有的运算符进行重新定义，赋予其另一种功能</span><br><span class="line">	1、加号的运算符重载</span><br><span class="line">	成员函数:	Person operator+ (Person &amp;p) &#123;</span><br><span class="line">			Person temp;</span><br><span class="line">			temp.a = this-&gt;a + p.a;</span><br><span class="line">			temp.b = this-&gt;b + p.b;</span><br><span class="line">			<span class="built_in">return</span> temp;</span><br><span class="line">		&#125;</span><br><span class="line">		调用:Person p3 = p1.operator+ (p2);</span><br><span class="line">		简化为:	Person p3 = p1 + p2;</span><br><span class="line">	全局函数:Person operator+ (Person &amp;p1, Person &amp;p2) &#123;</span><br><span class="line">			Person temp;</span><br><span class="line">			temp.a = p1.a + p2.a;</span><br><span class="line">			temp.b = p1.b + p2.b;</span><br><span class="line">			<span class="built_in">return</span> temp;</span><br><span class="line">		&#125;</span><br><span class="line">		调用:Person p3 = operator+ (p1, p2);</span><br><span class="line">		简化为:	Person p3 = p1 + p2;</span><br><span class="line">		2、左移运算符的重载</span><br><span class="line">	成员函数:	void operator &lt;&lt; ( ostream &amp;cout ) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">a &lt;&lt; &quot;\t&quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		调用时系统会简化为p &lt;&lt; cout，所以不推荐使用，只能利用全局函数实现</span></span><br><span class="line"><span class="string">	全局函数: 	ostream &amp; operator &lt;&lt; (ostream &amp;cout, Person &amp;p) &#123;</span></span><br><span class="line"><span class="string">			cout &lt;&lt; p.a</span> &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; <span class="string">p.b ;</span></span><br><span class="line"><span class="string">			return cout;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		调用时 cout &lt;&lt; p</span> &lt;&lt; <span class="string">endl	可以接着再往后追加，是因为返回值是一个ostream类型的引用，就是个链式编程的思想了</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3、递增运算符的重载 	</span><br><span class="line">		前置++运算符的重载	</span><br><span class="line">		MyInterger&amp; operator++() &#123;</span><br><span class="line">			num++;</span><br><span class="line">			<span class="built_in">return</span> *this;</span><br><span class="line">		&#125;	返回引用可以一只对同一个对象做操作</span><br><span class="line">		后置运算符的重载	后置++返回的是一个值，而不是引用</span><br><span class="line">		MyInterger operator++ (int) &#123;	用占位参数（int）区分前置和后置	</span><br><span class="line">			MyInterger temp = *this;</span><br><span class="line">			num ++;</span><br><span class="line">			<span class="built_in">return</span> temp;</span><br><span class="line">		&#125;</span><br><span class="line">	4、赋值运算符的重载</span><br><span class="line">		Person&amp; operator= (Person &amp;p) &#123;</span><br><span class="line">			<span class="keyword">if</span>(age != NULL) &#123;</span><br><span class="line">				delete age;</span><br><span class="line">				age = NULL;</span><br><span class="line">			&#125;</span><br><span class="line">			age = new int(p.age);	//深拷贝	</span><br><span class="line">			<span class="built_in">return</span> *this;</span><br><span class="line">		&#125;</span><br><span class="line">	5、关系运算符的重载</span><br><span class="line">		bool operator== (Person &amp;p) &#123;</span><br><span class="line">			<span class="keyword">if</span>(this-&gt;name == p.name &amp;&amp; this-&gt;age == p.age) &#123;</span><br><span class="line">				<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;	</span><br><span class="line">			<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	6、函数调用运算符的重载，重载小括号，也被称为仿函数</span><br><span class="line">		void operator() (string <span class="built_in">test</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">test &lt;&lt;;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		调用:	MyPrint myPrint;</span></span><br><span class="line"><span class="string">			myPrint(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="string">		仿函数非常灵活，没有固定的写法</span></span><br><span class="line"><span class="string">		int operator() (int num1, int num2) &#123;</span></span><br><span class="line"><span class="string">			return num1 + num2;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="继承"><a href="#继承" class="headerlink" title="继承:"></a>继承:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">语法:class Son : public Father &#123;&#125;	子类:继承方式（public） 父类，来继承想要继承的类</span><br><span class="line">	子类也称为派生类，父类也称为基类</span><br><span class="line">	继承方式一共有三种:不管哪种父类的私有成员都不能被继承	</span><br><span class="line">		1、公共继承</span><br><span class="line">			继承父类的public与protected成员，并且保持他们原有的权限</span><br><span class="line">		2、保护继承</span><br><span class="line">			继承父类非private的成员，并且全部更改为protected权限，保护权限在类外访问不了，可以访问的是:类自身，子类，友元</span><br><span class="line">		3、私有继承</span><br><span class="line">			继承父类非private的成员，并且全部更改为private权限</span><br><span class="line">	父类中所有的非静态成员都会被继承下去，只不过父类的私有成员被编译器隐藏了，是访问不到的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="在vs工具中查看类的对象模型（VS-2017的开发人员工具命令提示符）"><a href="#在vs工具中查看类的对象模型（VS-2017的开发人员工具命令提示符）" class="headerlink" title="在vs工具中查看类的对象模型（VS 2017的开发人员工具命令提示符）"></a>在vs工具中查看类的对象模型（VS 2017的开发人员工具命令提示符）</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">来到对应目录下输入: cl /d1 reportSingleClassLayout类名 <span class="string">&quot;xxxxx.cpp&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="继承中构造和析构的顺序"><a href="#继承中构造和析构的顺序" class="headerlink" title="继承中构造和析构的顺序:"></a>继承中构造和析构的顺序:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">父类的构造函数→子类的构造函数→子类的析构函数→父类的析构函数</span><br></pre></td></tr></table></figure>

<h1 id="继承中同名成员处理方式"><a href="#继承中同名成员处理方式" class="headerlink" title="继承中同名成员处理方式:"></a>继承中同名成员处理方式:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">访问父类的同名成员加上父类的作用域就行了</span><br><span class="line">	例:s.Father::age;	访问函数同理</span><br><span class="line">子类中有与父类同名的函数时，那么父类中所有的同名函数都会被隐藏（包括重载的函数），加上父类的作用域才可以访问</span><br></pre></td></tr></table></figure>

<h1 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式:"></a>继承同名静态成员处理方式:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	静态成员与非静态成员出现同名:访问子类同名成员直接访问，访问父类同名成员需要加作用域</span><br><span class="line">通过类名方式访问父类静态成员Son::Father::func()</span><br></pre></td></tr></table></figure>

<h1 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法:"></a>多继承语法:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class 子类:继承方式 父类1，继承方式 父类2....... &#123;  &#125;</span><br><span class="line">	实际开发中不建议多继承，可能会有同名成员，访问时需要加作用域</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">概念:两个派生类继承自一个基类，而这两个派生类又被同一个类所继承</span><br><span class="line">	利用虚继承解决菱形继承二义性（继承了两个年龄）的问题:加上virtual关键字，Animal类叫虚基类</span><br><span class="line">	class Animal &#123;punlic: int age&#125;;</span><br><span class="line">	class Sheep :virtual public Animal &#123;&#125;;</span><br><span class="line">	class Tuo :virtual public Animal &#123;&#125;;	</span><br><span class="line">	class SheepTuo :public Sheep, public Tuo &#123;&#125;;</span><br><span class="line">	加了virtual后，age只有一份了，并且可以直接st.age用子类的对象来赋值与访问</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="重写与重载的区别"><a href="#重写与重载的区别" class="headerlink" title="重写与重载的区别:"></a>重写与重载的区别:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">重写是函数名、形参列表、返回值类型都不变，改变方法体</span><br><span class="line">		重载是函数名相同，但形参列表不同</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="多态"><a href="#多态" class="headerlink" title="多态:"></a>多态:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">静态多态和动态多态的区别:</span><br><span class="line">	1、静态多态的函数地址早绑定 - 编译阶段确定函数地址</span><br><span class="line">	2、动态多态的函数地址晚绑定 - 运行阶段确定函数地址</span><br><span class="line">	在父类的函数前加上virtual，使其变为虚函数，继承的子类在重写此函数时就可以根据传入的对象来指向对应的子类</span><br><span class="line">	多态满足条件:有继承关系，子类重写父类中的虚函数</span><br><span class="line">	多态使用条件:父类指针或引用指向子类对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类:"></a>纯虚函数和抽象类:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">纯虚函数语法:virtual 返回值类型 函数名 （参数列表）= 0；</span><br><span class="line">只要有一个纯虚函数，这个类就叫抽象类</span><br><span class="line">抽象类特点:	1、无法实例化对象 </span><br><span class="line">		2、子类必须重写抽象类中的纯虚函数，否则也是属于抽象类</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构:"></a>虚析构和纯虚析构:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">用于解决多态使用时，有属性开辟到了堆区，父类指针在释放时无法调用到子类的析构代码</span><br><span class="line">		将父类中的析构函数改为虚析构或纯虚析构</span><br><span class="line">	虚析构与纯虚析构共性:	1、都能解决父类指针释放子类对象的问题</span><br><span class="line">				2、都需要有具体的函数实现</span><br><span class="line">	虚析构与纯虚析构区别:	如果是纯虚析构，呢么该类属于抽象类，无法实例化对象		</span><br><span class="line">	虚析构语法:	virtual ~类名() &#123;&#125;</span><br><span class="line">	纯虚析构语法:	virtual ~类名() = 0;	这是个声明</span><br><span class="line">纯虚析构要在class外写出实现，并要写作用域，例:Animal::~<span class="function"><span class="title">Animal</span></span>() &#123;   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="文件操作-对文件操作要加-include"><a href="#文件操作-对文件操作要加-include" class="headerlink" title="文件操作:对文件操作要加#include "></a>文件操作:对文件操作要加#include <fstream></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">文件类型:	1、文本文件 - 文件以文本的ASCII码存在计算机中</span><br><span class="line">			2、二进制文件 - 文件以二进制的形式存在计算机中，用户一般不能直接读懂它们	</span><br><span class="line">操作文件的三大类:	1、ofstream - 写操作	</span><br><span class="line">					2、ifstream - 读操作</span><br><span class="line">					3、fstream - 读写操作</span><br><span class="line">文本文件:写（读）文件步骤:	</span><br><span class="line">			1、包含头文件	<span class="comment">#include&lt;fstream&gt;</span></span><br><span class="line">			2、创建流对象	ofstream ofs;</span><br><span class="line">			3、打开文件	ofs.open(<span class="string">&quot;文件路径&quot;</span>，打开方式); 读文件时多一步:ifs.is_open()判断文件是否打开成功</span><br><span class="line">			4、写数据（读数据）	ofs &lt;&lt; <span class="string">&quot;写入的数据&quot;</span></span><br><span class="line">			5、关闭文件	ofs.close();</span><br><span class="line">	文件打开方式:	</span><br><span class="line">			ios::<span class="keyword">in</span>		为读文件而打开文件</span><br><span class="line">			ios::out		为写文件而打开文件	</span><br><span class="line">			ios::ate		初始位置:文件尾</span><br><span class="line">			ios::app		追加方式写文件</span><br><span class="line">			ios::trunc		如果文件存在，先删除，再创建</span><br><span class="line">			ios::binary		二进制方式</span><br><span class="line">			可以使用  |  操作符来配合使用</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">读数据的四种方法:	</span><br><span class="line">				第一种:	char buf[1024] = &#123; 0 &#125;;</span><br><span class="line">					<span class="keyword">while</span> (ifs &gt;&gt; buf) &#123;</span><br><span class="line">						cout &lt;&lt; <span class="string">buf &lt;&lt; endl;</span></span><br><span class="line"><span class="string">					&#125;	</span></span><br><span class="line"><span class="string">				第二种:	char buf</span>[1024] = &#123; 0 &#125;;</span><br><span class="line">					<span class="keyword">while</span> (ifs.getline(buf,sizeof(buf) ) ) &#123;</span><br><span class="line">						cout &lt;&lt; <span class="string">buf &lt;&lt; endl;</span></span><br><span class="line"><span class="string">					&#125;	</span></span><br><span class="line"><span class="string">				第三种:	string buf</span>;</span><br><span class="line">					<span class="keyword">while</span> (getline(ifs, buf)) &#123;</span><br><span class="line">						cout &lt;&lt; <span class="string">buf &lt;&lt; endl;</span></span><br><span class="line"><span class="string">					&#125;</span></span><br><span class="line"><span class="string">				第四种:	char c;</span></span><br><span class="line"><span class="string">					while((c = ifs.get() ) != EOF) &#123;  //END OF FILE文件尾</span></span><br><span class="line"><span class="string">						cout &lt;&lt; c;</span></span><br><span class="line"><span class="string">					&#125;</span></span><br><span class="line"><span class="string">		二进制方式读文件:打开方式  ios::binary		一样五个步骤</span></span><br><span class="line"><span class="string">			写文件时可以写任意文件，例:写入了一个对象p；ofs.write((const char *)&amp;p,sizeof(Person));</span></span><br><span class="line"><span class="string">		二进制方式读文件:</span></span><br><span class="line"><span class="string">			例:读入二进制文件到创建的对象p中:	ifs.open(&quot;person.txt&quot;,ios::in | ios::binary);//打开，之后要判断是否打开成功，用ifs.is_open()</span></span><br><span class="line"><span class="string">							ifs.read((char *)&amp;p,sizeof(Person));</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h1 id="模板"><a href="#模板" class="headerlink" title="模板:"></a>模板:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">泛型编程主要利用的技术是模板</span><br><span class="line">	1、模板只是一个框架，不能直接使用</span><br><span class="line">	2、模板的通用并不是万能的</span><br><span class="line">	</span><br><span class="line">	函数模板语法:	1、template&lt;typename T&gt;	typename也可以用class</span><br><span class="line">			2、函数声明或定义			</span><br><span class="line">		</span><br><span class="line">	例:	template&lt;typename T&gt;</span><br><span class="line">		void mySwap(T &amp;a, T &amp;b) &#123;</span><br><span class="line">			T temp = a;	</span><br><span class="line">			a = b;</span><br><span class="line">			b = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	使用的两种方法:	1、编译器自动推导</span><br><span class="line">			mySwap(a, b);</span><br><span class="line">			2、显示指定类型</span><br><span class="line">			mySwap&lt;int&gt;(a, b);</span><br><span class="line">	注意事项:	自动类型推导，必须要推导出一致的数据类型</span><br><span class="line">			模板必须要确定出T的数据类型才能使用</span><br><span class="line">			如果模板函数里没用到T，那只能强行给T指定一个类型才能正常使用</span><br><span class="line">			函数模板用自动类型推导不会发生隐式类型转换</span><br><span class="line">			函数模板用显示指定类型回发生隐式类型转换</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="普通函数与函数模板的调用规则"><a href="#普通函数与函数模板的调用规则" class="headerlink" title="普通函数与函数模板的调用规则:"></a>普通函数与函数模板的调用规则:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	1、如果普通函数与函数模板都可以实现，那么优先调用普通函数</span><br><span class="line">	2、可以通过空模板参数列表来强制调用函数模板 	例:func&lt;&gt;(a, b);	加上一个空的&lt;&gt;，可以强制调用函数模板</span><br><span class="line">	3、函数模板也可以发生重载</span><br><span class="line">	4、如果函数模板可以产生更好的匹配，优先调用函数模板</span><br><span class="line"></span><br><span class="line">给模板一个具体数据类型的实现代码，传入的数据类型符合优先调用</span><br><span class="line">	例:在模板下追加</span><br><span class="line">	template&lt;&gt; bool myCompare(Person &amp;a, Person &amp;b) &#123;......&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="类模板语法"><a href="#类模板语法" class="headerlink" title="类模板语法:"></a>类模板语法:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、template&lt;class T&gt;</span><br><span class="line">2、类</span><br><span class="line"></span><br><span class="line">声明模板时可以写多个类型，例:	template&lt;class A, class B&gt;</span><br><span class="line">调用时分别指定数据类型	Person&lt;string, int&gt; p(<span class="string">&quot;plf&quot;</span>, 18);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="类模板与函数模板的区别"><a href="#类模板与函数模板的区别" class="headerlink" title="类模板与函数模板的区别:"></a>类模板与函数模板的区别:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、类模板没有自动类型推导的使用方式</span><br><span class="line">2、类模板在模板参数列表中可以有默认参数，函数模板不可以</span><br><span class="line">	例:template&lt;class A, class B = int&gt;	给一个默认数据类型</span><br><span class="line">	调用不写就是默认的:Person&lt;string&gt; p(<span class="string">&quot;plf&quot;</span>, 18);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="类模板中成员函数的创建时机"><a href="#类模板中成员函数的创建时机" class="headerlink" title="类模板中成员函数的创建时机:"></a>类模板中成员函数的创建时机:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、普通类的成员函数一开始就可以创建</span><br><span class="line">2、类模板中的成员函数在调用时才去创建</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="查看模板参数类型"><a href="#查看模板参数类型" class="headerlink" title="查看模板参数类型:"></a>查看模板参数类型:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typeid(T1).name()	会返回一个string类型，输出显示就能看到</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数:"></a>类模板对象做函数参数:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、指定传入类型</span><br><span class="line">	void func(Person&lt;string, int&gt; &amp;p) &#123;......&#125;</span><br><span class="line">2、参数模板化</span><br><span class="line">	template&lt;class T1, class T2&gt;</span><br><span class="line">	void func(Person&lt;T1, T2&gt; &amp;p) &#123;......&#125;</span><br><span class="line">3、整个类模板化</span><br><span class="line">	template&lt;class T&gt;</span><br><span class="line">	void func(T &amp;p) &#123;......&#125;	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承:"></a>类模板与继承:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、继承父类的类模板时，子类在声明时要指定出父类的T的类型	</span><br><span class="line">	class Son :public Father&lt;int&gt; &#123;......&#125;;</span><br><span class="line">2、如果不指定，编译器无法给子类分配内存</span><br><span class="line">3、如果想灵活指出父类中的T的类型，子类也需要变成类模板	</span><br><span class="line">	template&lt;class T1, class T2&gt;</span><br><span class="line">	class Son :public Father&lt;T2&gt; &#123; public:T1 age&#125;;	T2是用来指定继承自父类的T的数据类型，T1用于自身的数据类型</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="类模板的成员函数类外实现"><a href="#类模板的成员函数类外实现" class="headerlink" title="类模板的成员函数类外实现:"></a>类模板的成员函数类外实现:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">构造函数:	template&lt;class T1, class T2&gt;</span><br><span class="line">	Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;.....&#125;</span><br><span class="line">普通函数:	template&lt;class T1, class T2&gt;</span><br><span class="line">	void Person&lt;T1, T2&gt;::<span class="function"><span class="title">func</span></span>() &#123;.....&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="类模板的分文件编写"><a href="#类模板的分文件编写" class="headerlink" title="类模板的分文件编写:"></a>类模板的分文件编写:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、直接包含cpp文件	分了cpp和h文件，直接<span class="comment">#include &quot;person.cpp&quot;</span></span><br><span class="line">2、将声明和实现写到同一个文件，并更改后缀名为hpp（hpp是约定俗成的名称）hpp文件放在头文件一栏中</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元:"></a>类模板与友元:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、全局函数类内实现</span><br><span class="line">	在class下第一行friend void <span class="function"><span class="title">func</span></span>() &#123;...&#125;	虽然写在class内，但并没有在权限后面，所以这是个全局函数，加friend访问类内的私有成员</span><br><span class="line">2、全局函数类外实现</span><br><span class="line">	类内写声明</span><br><span class="line">	例:friend void func&lt;&gt;(Person&lt;T1, T2&gt; p);	要加&lt;&gt;，不然会和类外的实现无法连接起来</span><br><span class="line">	类外在写实现时不需要加Person作用域，因为这是个全局函数,并且要写在类内声明的类的上面，因为声明中有Person类，所以要把Person类的声明再在全局函数的声明上面写上，并且要加上template&lt;class T1, class T2&gt;表示这是一个模板类</span><br><span class="line">	例:	template&lt;class T1, class T2&gt;</span><br><span class="line">		friend void func&lt;&gt;(Person&lt;T1, T2&gt; p) &#123;  ...  &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="STL"><a href="#STL" class="headerlink" title="STL:"></a>STL:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">概念:标准模板库（Standard Template Library）</span><br><span class="line">	广义上分为:容器（container）算法（algorithm）迭代器（itetator）</span><br><span class="line">	容器和算法之间通过迭代器进行无缝连接</span><br><span class="line">	STL几乎所有的代码都采用了模板类或模板函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="vector容器-include-包含头文件"><a href="#vector容器-include-包含头文件" class="headerlink" title="vector容器:#include 	包含头文件"></a>vector容器:#include <vector>	包含头文件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">		vector&lt;int&gt; v;	新建对象</span><br><span class="line">		v.push_back(10);	尾插数据</span><br><span class="line">        	遍历数据的三种方式:   </span><br><span class="line">	            1、vector&lt;int&gt;::iterator itBegin = v.begin();	//指向第一个元素的位置</span><br><span class="line">		vector&lt;int&gt;::iterator itEnd = v.end();		//指向最后一个元素的后一个位置</span><br><span class="line">		<span class="keyword">while</span> (itBegin != itEnd) &#123;</span><br><span class="line">			cout &lt;&lt; *itBegin &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">			itBegin++;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	            2、for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span></span><br><span class="line"><span class="string">			cout &lt;&lt; *it &lt;&lt; endl</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	            3、利用算法要<span class="comment">#include&lt;algorithm&gt;	//标准算法头文件</span></span><br><span class="line">		for_each(v.begin(), v.end(), myPrint)	//参数:起始位置，结束位置,打印函数函数名</span><br><span class="line">	vector容器中存放自定义数据类型:</span><br><span class="line">		vector&lt;Person*&gt; v;</span><br><span class="line">		v.push_back(&amp;p1);</span><br><span class="line">		<span class="keyword">for</span> (vector&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">			cout &lt;&lt; (*it)-&gt;name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; (*it)-&gt;age &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="vector容器嵌套容器"><a href="#vector容器嵌套容器" class="headerlink" title="vector容器嵌套容器:"></a>vector容器嵌套容器:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	vector&lt; vector&lt;int&gt; &gt; v;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt; vector&lt;int&gt; &gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) &#123;</span><br><span class="line">			cout &lt;&lt; *vit &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="string容器"><a href="#string容器" class="headerlink" title="string容器:"></a>string容器:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">构造函数:1、string()		创建一个空的字符串:string str</span><br><span class="line">	2、string(const char * s)	传入一个s来初始化字符串</span><br><span class="line">	3、string(const string&amp; str)	使用另一个string对象来初始化字符串（拷贝构造）</span><br><span class="line">	4、string(int n, char c)	初始化n个c的字符串</span><br><span class="line">赋值操作:1、等号赋值	str = <span class="string">&quot;hello&quot;</span></span><br><span class="line">	2、成员函数	str.assign(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">			str.assign(<span class="string">&quot;hello&quot;</span>, 4)	把字符串前4个赋值过来</span><br><span class="line">			str.assign(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">			str.assign(str1)	把str1赋值给str</span><br><span class="line">			str.assign(10, <span class="string">&#x27;a&#x27;</span>)	10个a赋值给str</span><br><span class="line">字符串的拼接:</span><br><span class="line">	1、运算符+=重载	str += <span class="string">&quot;World&quot;</span>;  str += <span class="string">&#x27;a&#x27;</span>;  str += str1;</span><br><span class="line">	2、成员函数	str.append(<span class="string">&quot;World&quot;</span>)	将字符串追加到字符串结尾，也可以追加字符与string对象</span><br><span class="line">			str.append(str1, pos, n)将字符串str1从pos开始的n个字符串追加到字符串结尾</span><br><span class="line">string的查找与替换:</span><br><span class="line">	1、查找	str.find(<span class="string">&quot;ab&quot;</span>)	返回第一次出现位置（int），可以写上从第一个位置开始查，不写默认从0开始</span><br><span class="line">		str.rfind(<span class="string">&quot;ab&quot;</span>)	返回最后一次出现的位置（int），找不到返回-1</span><br><span class="line">	2、替换	str.replace(pos, n, str1)	替换从第pos开始的n个字符为str1</span><br><span class="line">string字符串比较:比较是按照ASCII码进行比较的，返回值:==（0），&gt;（1），&lt;（-1）</span><br><span class="line">	str.compare(str1)	str与str1进行比较，例:str &gt; str1			</span><br><span class="line">string字符存取:</span><br><span class="line">	单个字符存取方式:	1、str[n]		通过[]来存取单个字符</span><br><span class="line">			2、str.at(n)	通过成员函数at			</span><br><span class="line">string插入与删除:</span><br><span class="line">	插入:insert	str.insert(pos, <span class="string">&quot;hello&quot;</span>) 	在pos位置插入字符串</span><br><span class="line">			str.insert(pos, n, <span class="string">&#x27;c&#x27;</span>)		在pos位置插入n个字符c</span><br><span class="line">	删除:erase	str.erase(pos, n)		删除从pos开始的n个字符</span><br><span class="line">string子串:</span><br><span class="line">	str1 = str.substr(pos, n)	返回从pos位置开始n个字符</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器:"></a>vector容器:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">概念:和数组非常相似，也称为单端数组</span><br><span class="line">与数组区别:数组是静态空间，而vector可以动态拓展</span><br><span class="line">动态拓展:并不是在元空间之后续借空间，而是找块更大的内存空间，然后将元数据拷贝新空间，释放原空间</span><br><span class="line">vector构造函数:</span><br><span class="line">	vector&lt;T&gt; v;		默认构造函数</span><br><span class="line">	vector&lt;T&gt;v2(v.begin(), v.end())	将v[begin(), end())区间中的元素拷贝给本身</span><br><span class="line">	vector&lt;T&gt;v3(m, elem);	构造函数将n个elem拷贝给本身，例:10个100</span><br><span class="line">	vector&lt;T&gt;v4(v3)		拷贝构造函数</span><br><span class="line">vector赋值操作:</span><br><span class="line">	1、=赋值		v2 = v1;</span><br><span class="line">	2、assign成员函数</span><br><span class="line">		v2.assign(v1.begin(), v1.end())	取v1区间的值来赋值给v2</span><br><span class="line">		v2.assign(10, 100)		赋值10个100</span><br><span class="line">vector容量和大小:</span><br><span class="line">	empty()		判断是否为空</span><br><span class="line">	capacity()		容器的容量</span><br><span class="line">	size()		返回元素的个数</span><br><span class="line">	resize(num)	重新指定容器的长度为num，若容器变长，则以elem填充（默认不写为0），若容器变短，删除末尾超出容器长度的元素	</span><br><span class="line">	resize(num, elem)	可以指定默认填充的值</span><br><span class="line">vector插入和删除:</span><br><span class="line">	push_back(val)	尾插val</span><br><span class="line">	pop_back()	尾删</span><br><span class="line">	insert(pos, val)	迭代器指向位置pos插入val</span><br><span class="line">	insert(pos, n, val)	迭代器指向位置pos插入n个val	</span><br><span class="line">	erase(pos)	删除迭代器pos指向的元素</span><br><span class="line">	earse(start, end)	删除迭代器start到end之间的元素</span><br><span class="line">	clear()		清空容器中所有元素</span><br><span class="line">vector数据存取:</span><br><span class="line">	v.at(index)	返回index所指的数据</span><br><span class="line">	v[index]		返回index所指的数据</span><br><span class="line">	v.front()		返回容器中第一个元素</span><br><span class="line">	v.back()		返回容器中最后一个元素</span><br><span class="line">vector互换容器:</span><br><span class="line">	swap(vec)		将vec与本身的元素互换</span><br><span class="line">巧用swap收缩内存	</span><br><span class="line">	例:vector&lt;int&gt;(v).swap(v)	vector&lt;int&gt;(v)调用拷贝构造函数拷贝v建造一个匿名对象，匿名对象来与原有的v进行交换，那么，被交换过来的内存在执行完这一句后，就会被系统释放，回收原来v中多余的内存，注意括号不能少	</span><br><span class="line">vector预留空间:</span><br><span class="line">	reserve(int len)	容器预留了内个元素长度，预留位置不初始化，元素不可访问</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="deque容器-迭代器支持随机访问"><a href="#deque容器-迭代器支持随机访问" class="headerlink" title="deque容器:迭代器支持随机访问"></a>deque容器:迭代器支持随机访问</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deque容器是双端数组，可以对头部进行插入删除操作</span><br><span class="line">与vector的区别:	vector对于头部的插入删除效率低，deque对头部的插入删除速度比vector快</span><br><span class="line">		vector访问元素时的速度会比deque快</span><br><span class="line">构造函数:deque&lt;T&gt; d;		默认构造函数</span><br><span class="line">	deque&lt;T&gt;d2(d.begin(),d.end())	将d[begin(), end())区间中的元素拷贝给本身</span><br><span class="line">	deque&lt;T&gt;d3(m, elem);	构造函数将n个elem拷贝给本身，例:10个100</span><br><span class="line">	deque&lt;T&gt;d4(d3)		拷贝构造函数</span><br><span class="line">void func(const deque&lt;int&gt; &amp;d)	</span><br><span class="line">当形参用const修饰了后，那么普通的迭代器就无法使用了，要用const_iterator</span><br><span class="line">例:deque&lt;int&gt;::const_iterator it = d.begin()</span><br><span class="line">deque容器赋值操作:</span><br><span class="line">	1、=赋值		d2 = d1;</span><br><span class="line">	2、assign成员函数</span><br><span class="line">		d2.assign(d1.begin(), d1.end())	取d1区间的值来赋值给d2</span><br><span class="line">		d2.assign(10, 100)		赋值10个100</span><br><span class="line">deque容器的大小操作:	没有容量（capacity）</span><br><span class="line">	empty()		判断是否为空</span><br><span class="line">	size()		返回元素的个数</span><br><span class="line">	resize(num)	重新指定容器的长度为num，若容器变长，则以elem填充（默认不写为0），若容器变短，删除末尾超出容器长度的元素	</span><br><span class="line">	resize(num, elem)	可以指定默认填充的值</span><br><span class="line">deque容器插入和删除:</span><br><span class="line">	push_front(val)	头插val</span><br><span class="line">	pop_front()	头删</span><br><span class="line">	push_back(val)	尾插val</span><br><span class="line">	pop_back()	尾删</span><br><span class="line">	insert(pos, val)	迭代器指向位置pos插入val</span><br><span class="line">	insert(pos, n, val)	迭代器指向位置pos插入n个val	</span><br><span class="line">	erase(pos)	删除迭代器pos指向的元素</span><br><span class="line">	earse(start, end)	删除迭代器start到end之间的元素</span><br><span class="line">	clear()		清空容器中所有元素</span><br><span class="line">deque数据存取:</span><br><span class="line">	d.at(index)	返回index所指的数据</span><br><span class="line">	d[index]		返回index所指的数据</span><br><span class="line">	d.front()		返回容器中第一个元素</span><br><span class="line">	d.back()		返回容器中最后一个元素</span><br><span class="line">deque排序:</span><br><span class="line">	<span class="comment">#include&lt;algorithm&gt;	//标准算法头文件</span></span><br><span class="line">	利用一个<span class="built_in">sort</span>算法</span><br><span class="line">	<span class="built_in">sort</span>(d.begin(), d.end())	（默认升序）对迭代器start和end区间内的元素进行排序</span><br><span class="line">	对于支持随机访问的迭代器容器都可以用<span class="built_in">sort</span>算法，vector也可以</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="随机数的获取"><a href="#随机数的获取" class="headerlink" title="随机数的获取:"></a>随机数的获取:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">包含头文件<span class="comment">#include &lt;ctime&gt;</span></span><br><span class="line">在main第一行加入一个随机数种子:srand((unsigned int)time(NULL));		</span><br><span class="line">调用rand()，例:想要0-99随机数rand()%100，40-60:rand()%21 + 40</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器:"></a>stack容器:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	先进后出的数据结构，它只有一个出口</span><br><span class="line">	栈中只有顶端的元素才可以被使用，因此栈不允许有遍历行为</span><br><span class="line">	栈是自顶向下的，所以栈底在最上面，栈顶在最下面</span><br><span class="line">	top()	栈顶的元素</span><br><span class="line">	push()	向栈里添加数据，称为进栈</span><br><span class="line">	pop()	在栈里删除数据，称为出栈</span><br><span class="line">	构造函数:stack&lt;T&gt; stk	默认构造</span><br><span class="line">		stack&lt;T&gt; stk(stk1)	拷贝构造</span><br><span class="line">	赋值操作:=赋值: stack&lt;T&gt; stk = stk1</span><br><span class="line">	数据存取:push(elem)	向栈顶添加元素		</span><br><span class="line">		pop()		从栈顶删除第一个元素</span><br><span class="line">		top()		返回栈顶元素</span><br><span class="line">	大小操作:empty()		判断是否为空</span><br><span class="line">size()		返回栈的大小</span><br></pre></td></tr></table></figure>

<h1 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器:"></a>queue容器:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">queue容器是一种先进先出的数据结构，叫做队列，队列方向从对尾到对头</span><br><span class="line">队尾（back）只进，对头（front）只出，push向队尾添加数据，叫入队，pop在对头删除数据，叫出队</span><br><span class="line">队列中只有对头和队尾才能被外界使用，因此不允许有遍历行为</span><br><span class="line">构造函数:queue&lt;T&gt; que		默认构造</span><br><span class="line">	queue&lt;T&gt; que(que1)	拷贝构造</span><br><span class="line">赋值操作:=赋值:queue&lt;T&gt; que = que1</span><br><span class="line">数据存取:push(elem)	向队尾添加元素，入队		</span><br><span class="line">	pop()		从对头删除第一个元素，出队</span><br><span class="line">	front()		返回对头元素</span><br><span class="line">	back()		返回队尾元素</span><br><span class="line">大小操作:empty()		判断是否为空</span><br><span class="line">	size()		返回队列的大小</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="list容器"><a href="#list容器" class="headerlink" title="list容器:"></a>list容器:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能:将数据进行链式存储</span><br><span class="line">	链表的组成:链表由一系列结点组成</span><br><span class="line">	结点的组成:一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</span><br><span class="line">	STL中的链表是一个双向循环链表，指针域有两个指针，一个指针指向下一结点位置，另一指针指向上一结点位置，循环表示最后一个节点的指针域不是指向NULL了，而是指向第一个结点的位置</span><br><span class="line">	链表优点:采用动态内存分配，不会造成内存浪费和溢出</span><br><span class="line">		可以对任意位置进行快速插入或删除</span><br><span class="line">		插入和删除都不会导致原有迭代器的失效，这在vector中是不行的</span><br><span class="line">	链表缺点:容器遍历速度没有数组快，占用空间比数组大</span><br><span class="line">	链表中的迭代器:只支持前移和后移，属于双向迭代器，不支持随机访问</span><br><span class="line">	构造函数:list&lt;T&gt; L1;		默认构造函数</span><br><span class="line">		list&lt;T&gt;L2(L1.begin(),L1.end())	将L1[begin(), end())区间中的元素拷贝给本身</span><br><span class="line">		list&lt;T&gt;L3(m, elem);		构造函数将n个elem拷贝给本身，例:10个100</span><br><span class="line">		list&lt;T&gt;L4(L3)		拷贝构造函数</span><br><span class="line">	list赋值与交换:</span><br><span class="line">		=赋值		L2 = L1;</span><br><span class="line">		assign成员函数赋值</span><br><span class="line">			L2.assign(L1.begin(), L1.end())	取L1区间的值来赋值给L2</span><br><span class="line">			L2.assign(10, 100)		赋值10个100</span><br><span class="line">		L2.swap(L1)	将L1中的元素与L2自身的元素做交换</span><br><span class="line">	list大小操作:</span><br><span class="line">		empty()		判断是否为空</span><br><span class="line">		size()		返回元素的个数</span><br><span class="line">		resize(num)	重新指定容器的长度为num，若容器变长，则以elem填充（默认不写为0），若容器变短，删除末尾超出容器长度的元素	</span><br><span class="line">		resize(num, elem)	可以指定默认填充的值</span><br><span class="line">	list插入和删除:</span><br><span class="line">		push_front(val)	头插val</span><br><span class="line">		pop_front()	头删</span><br><span class="line">		push_back(val)	尾插val</span><br><span class="line">		pop_back()	尾删</span><br><span class="line">		insert(pos, val)	迭代器指向位置pos插入val</span><br><span class="line">		insert(pos, n, val)	迭代器指向位置pos插入n个val	</span><br><span class="line">		insert(pos,beg,end)	迭代器指向位置pos插入[beg, end)区间的数据</span><br><span class="line">		erase(pos)	删除迭代器pos指向的元素</span><br><span class="line">		earse(start, end)	删除迭代器start到end之间的元素</span><br><span class="line">		clear()		清空容器中所有元素	</span><br><span class="line">		remove(elem)	删除容器中所有与elem匹配的元素，例:remove(10)</span><br><span class="line">	list数据存取:不支持[]与at()访问，只能it++，而不能it = it +1</span><br><span class="line">		front()		返回第一个元素</span><br><span class="line">		back()		返回最后一个元素</span><br><span class="line">	list反转与排序:所有不支持随机访问的迭代器，不可以用标准算法，内部会提供一些成员函数，所以<span class="built_in">sort</span>是个成员函数，而不是算法</span><br><span class="line">		L1.reverse()	反转链表</span><br><span class="line">		L1.<span class="built_in">sort</span>()		排序链表（默认升序，从小到大）</span><br><span class="line">		降序:	bool my Compare(int v1, int v2) &#123;</span><br><span class="line">				<span class="built_in">return</span> v1 &gt; v2;</span><br><span class="line">			&#125;</span><br><span class="line">			L1.<span class="built_in">sort</span>(myCompare)	</span><br><span class="line">			自己提供一个函数v1&gt;v2返回<span class="literal">true</span>，将函数名传入<span class="built_in">sort</span></span><br><span class="line">		例:高级排序写法（按照年龄升序排序，年龄相同按照身高降序排序）</span><br><span class="line">		bool comparePerson(Person &amp;p1, Person &amp;p2) &#123;</span><br><span class="line">			<span class="keyword">if</span> (p2.age == p2.age) &#123;</span><br><span class="line">				p1.height &gt; p2.height;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">return</span> p1.age &lt; p2.age;</span><br><span class="line">		&#125;</span><br><span class="line">		L1.<span class="built_in">sort</span>(comparePerson);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="set-x2F-multiset容器-都是包含-include"><a href="#set-x2F-multiset容器-都是包含-include" class="headerlink" title="set&#x2F;multiset容器:都是包含#include"></a>set&#x2F;multiset容器:都是包含#include<set></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>基本概念:所有元素在插入时自动被排序（升序）</span><br><span class="line">本质:<span class="built_in">set</span>/multiset属于关联式容器，底层结构用二叉树实现</span><br><span class="line"><span class="built_in">set</span>与multiset区别:<span class="built_in">set</span>不允许有重复的元素，multiset允许有重复的元素</span><br><span class="line"><span class="built_in">set</span>构造和赋值:</span><br><span class="line">	<span class="built_in">set</span>&lt;T&gt; st		默认构造</span><br><span class="line">	<span class="built_in">set</span>&lt;T&gt; st(st1)	拷贝构造</span><br><span class="line">	=赋值		st2 = st1;</span><br><span class="line"><span class="built_in">set</span>大小和交换:</span><br><span class="line">	empty()		判断是否为空</span><br><span class="line">	size()		返回元素的个数</span><br><span class="line">	st2.swap(st1)	交换st1与st2</span><br><span class="line"><span class="built_in">set</span>插入和删除:</span><br><span class="line">	insert(val)		在容器中插入val</span><br><span class="line">	erase(pos)	删除迭代器pos指向的元素，返回下一个元素的迭代器</span><br><span class="line">	earse(start, end)	删除迭代器区间start到end之间的元素，返回下一个元素的迭代器</span><br><span class="line">	erase(val)		删除容器中值为val的元素</span><br><span class="line">	clear()		清空容器中所有元素	</span><br><span class="line"><span class="built_in">set</span>查找和统计:</span><br><span class="line">	find(key)		查找key是否存在，若存在返回该键的元素的迭代器，不存在返回set.end()</span><br><span class="line">	count(key)	统计key的元素个数，对于<span class="built_in">set</span>而言，要么0，要么1，因为不可以重复，multiset可以</span><br><span class="line"><span class="built_in">set</span>和multiset区别:</span><br><span class="line">	1、<span class="built_in">set</span>不允许有重复的元素，multiset允许有重复的元素</span><br><span class="line">	2、<span class="built_in">set</span>插入数据的同时会返回插入结果，表示是否插入成功</span><br><span class="line">		pair&lt;<span class="built_in">set</span>&lt;int&gt;::iterator, bool&gt; ret = set.insert(10)	用pair对组接收	ret.second可以访问接收到的bool数据</span><br><span class="line">	3、multiset不会检测数据，因此可以重复插入</span><br><span class="line"><span class="built_in">set</span>容器排序:</span><br><span class="line">1、<span class="built_in">set</span>存放内置数据类型</span><br><span class="line">	指定排序为从大到小，例:		</span><br><span class="line">	class MyCompare &#123;</span><br><span class="line">	public:</span><br><span class="line">		bool operator() (int v1, int v2) &#123;</span><br><span class="line">			<span class="built_in">return</span> v1 &gt; v2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">set</span>&lt;int,MyCompare&gt;s;	插入数据之前就定好排序规则，模板列表中要放的是一个数据类型，所以要放类名，放函数名是不行的</span><br><span class="line">2、<span class="built_in">set</span>存放自定义数据类型</span><br><span class="line">	class MyCompare &#123;</span><br><span class="line">	public:</span><br><span class="line">		bool operator() (const Person&amp; p1, const Person&amp; p2) &#123;</span><br><span class="line">			<span class="built_in">return</span> p1.age &gt; p2.age;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">set</span>&lt;Person,MyCompare&gt;s;	存放自定义数据类型都要指定排序规则</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="pair对组"><a href="#pair对组" class="headerlink" title="pair对组"></a>pair对组</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">创建方式:1、pair&lt;<span class="built_in">type</span>, <span class="built_in">type</span>&gt; p (value1, value2)	创建并赋初值</span><br><span class="line">		2、pair&lt;<span class="built_in">type</span>, <span class="built_in">type</span>&gt; p = make_pair(value1, value2)</span><br><span class="line">	数据获取:p.first和p.second来获取第一个和第二个数据</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="map-x2F-multimap容器"><a href="#map-x2F-multimap容器" class="headerlink" title="map&#x2F;multimap容器:"></a>map&#x2F;multimap容器:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">map中所有元素都是pair</span><br><span class="line">pair第一个元素是键值（key），起到索引作用，第二个元素为实值（value）</span><br><span class="line">所有的元素都会根据键值自动排序</span><br><span class="line">属于关联式容器，底层结构是用二叉树实现</span><br><span class="line">优点:可以根据key值快速找到value值</span><br><span class="line">map与multimap区别:map不允许有重复的key值，multimap允许（key值有限制，但是value值都可以有重复的）</span><br><span class="line">map构造和赋值:</span><br><span class="line">	map&lt;T1, T2&gt; mp		默认构造</span><br><span class="line">	map&lt;T1, T2&gt; mp(mp2)	拷贝构造</span><br><span class="line">	map&lt;T1, T2&gt; mp = mp2	等号赋值</span><br><span class="line">map大小和交换:</span><br><span class="line">	empty()		判断是否为空</span><br><span class="line">	size()		返回元素的个数</span><br><span class="line">	mp2.swap(mp1)	交换mp1与mp2</span><br><span class="line">map插入和删除:</span><br><span class="line">	erase(pos)	删除迭代器pos指向的元素，返回下一个元素的迭代器</span><br><span class="line">	earse(start, end)	删除迭代器区间start到end之间的元素，返回下一个元素的迭代器</span><br><span class="line">	erase(key)		删除容器中值为key的元素，删除一对元素</span><br><span class="line">	clear()		清空容器中所有元素			</span><br><span class="line">	m.insert(pair&lt;int, int&gt;(1,10))	在容器中插入pair对组，以下还有三种方式</span><br><span class="line">	m.insert(make_pair(2, 20))	不用写模板参数</span><br><span class="line">	m.insert(map&lt;int, int&gt;::value_type(3, 30))</span><br><span class="line">	m[4] = 40;</span><br><span class="line">map查找和统计:</span><br><span class="line">	find(key)		查找key是否存在，若存在返回该键的元素的迭代器，不存在返回map.end()</span><br><span class="line">	count(key)	统计key的元素个数，对于map而言，要么0，要么1，因为不可以重复，multimap可以</span><br><span class="line">map容器排序:默认从小到大排序，利用仿函数改为了从大到小排序</span><br><span class="line">	class MyCompare &#123;</span><br><span class="line">	public:</span><br><span class="line">		bool operator() (int v1, int v2) &#123;</span><br><span class="line">			<span class="built_in">return</span> v1 &gt; v2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	map&lt;int,int,MyCompare&gt;mp;		改为了从大到小排序</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">重载了函数调用操作符，也叫仿函数</span><br><span class="line">	函数对象（仿函数），本质上是一个类，不是一个函数	</span><br><span class="line">	class MyAdd &#123;</span><br><span class="line">	public:</span><br><span class="line">		int operator() (int v1, int v2) &#123;</span><br><span class="line">			<span class="built_in">return</span> v1 + v2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	MyAdd myAdd;</span><br><span class="line">	myAdd(10, 10);	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="谓词"><a href="#谓词" class="headerlink" title="谓词:"></a>谓词:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、返回bool类型的仿函数称为谓词</span><br><span class="line">	2、如果operator()接收一个参数，那么叫做一元谓词</span><br><span class="line">	3、如果operator()接收两个参数，那么叫做二元谓词</span><br><span class="line">	class GreateFive &#123;</span><br><span class="line">	public:</span><br><span class="line">		bool opeerator() (int val) &#123;</span><br><span class="line">			<span class="built_in">return</span> val &gt; 5;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="内建函数对象-include"><a href="#内建函数对象-include" class="headerlink" title="内建函数对象:#include "></a>内建函数对象:#include <functional></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、算术仿函数</span><br><span class="line">	T plus &lt;T&gt;	加法仿函数</span><br><span class="line">	T minux &lt;T&gt;	减法仿函数</span><br><span class="line">	T multiplies &lt;T&gt;	乘法仿函数</span><br><span class="line">	T divides &lt;T&gt;	除法仿函数</span><br><span class="line">	T modulus &lt;T&gt;	取模仿函数</span><br><span class="line">	T negate &lt;T&gt;	取反仿函数</span><br><span class="line">	使用示例:1、包含头文件</span><br><span class="line">		2、新建对象	plus&lt;int&gt; n;</span><br><span class="line">		3、调用仿函数	n(10, 20)</span><br><span class="line">2、关系仿函数</span><br><span class="line">	bool equal_to&lt;T&gt;		等于	</span><br><span class="line">	bool no_equal_to&lt;T&gt;	不等于</span><br><span class="line">	bool greater&lt;T&gt;		大于</span><br><span class="line">	bool greater_equal&lt;T&gt;	大于等于</span><br><span class="line">	bool less&lt;T&gt;		小于</span><br><span class="line">	bool less_equal&lt;T&gt;		小于等于</span><br><span class="line">3、逻辑仿函数</span><br><span class="line">	bool logical_and &lt;T&gt;	逻辑与</span><br><span class="line">	bool logical_or &lt;T&gt;		逻辑或</span><br><span class="line">	bool logical_not &lt;T&gt;	逻辑非</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="STL常用算法"><a href="#STL常用算法" class="headerlink" title="STL常用算法:"></a>STL常用算法:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">算法主要由头文件algorithm，functional，numeric</span><br><span class="line">algorithm:是所有STL头文件最大的一个，范围涉及到比较、交换、查找、遍历操作、赋值、修改等等</span><br><span class="line">numeric:体积很小，只包括了几个在序列上进行简单数学运算的模板函数</span><br><span class="line">functional:定义了一些模板类，用以声明函数对象</span><br><span class="line">常用遍历算法:</span><br><span class="line">1、for_each	遍历容器</span><br><span class="line">	for_each(v.begin(), v.end(), printValue)	第三个参数可以是普通函数名，也可以是个仿函数</span><br><span class="line">	for_each(v.begin(), v.end(), printValue())	仿函数写法，传入printValue类的匿名对象</span><br><span class="line">2、transform	搬运容器到另一个容器中</span><br><span class="line">	v2.resize(v1.size())		目标容器需要提前开辟空间</span><br><span class="line">	transform(v1.begin(), v1.end(), v2.begin(), TransForm())	原容器开始迭代器，原容器结束迭代器，目标容器开始迭代器，普通函数或仿函数</span><br><span class="line">常用查找算法:</span><br><span class="line">1、find		查找元素</span><br><span class="line">	find(v.begin(), v.end(), value)	找到返回摘到位置的迭代器，没找到返回结束位置迭代器v.end()</span><br><span class="line">	查找自定义数据类型时，要重载==号，不然无法进行当前遍历对象与目标之间的判断操作</span><br><span class="line">	bool operator== (const Person &amp;p) &#123;</span><br><span class="line">		<span class="keyword">if</span>(this-&gt;name == p.name &amp;&amp; this-&gt;age == p.age) </span><br><span class="line">			<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">2、find_if		按条件查找元素，找到返回摘到位置的迭代器，没找到返回结束位置迭代器v.end()</span><br><span class="line">	find_if(v.begin(), v.end(), FindTest())	起始位置迭代器，结束位置迭代器，谓词（返回bool类型的仿函数）或_Pred函数（普通函数返回bool）</span><br><span class="line">3、adjacent_find	查找相邻重复元素</span><br><span class="line">	adjacent_find(v.begin(), v.end())	找到返回相邻元素第一个位置的迭代器，没找到返回结束位置迭代器	</span><br><span class="line">4、binary_search	二分查找法，在无序序列中不可用</span><br><span class="line">	binary_search(v.begin(), v.end(), value)	查到返回<span class="literal">true</span>，否则返回<span class="literal">false</span>			</span><br><span class="line">5、count		统计元素个数</span><br><span class="line">	count(v.begin(), v.end(), value)		返回int数据，统计出现元素个数</span><br><span class="line">	统计自定义数据类型要重载==</span><br><span class="line">6、count_if	按条件统计元素个数</span><br><span class="line">	count(v.begin(), v.end(), GreaterFive())	传入谓词（返回bool类型仿函数）	</span><br><span class="line">常用排序算法:</span><br><span class="line">1、<span class="built_in">sort</span>		对容器内元素进行排序</span><br><span class="line">	<span class="built_in">sort</span>(v.begin(), v.end())	第三个参数不填默认升序，填的话填谓词，自己写排序规则</span><br><span class="line">	改为降序可以直接用greater&lt;int&gt;()的内置函数对象，要<span class="comment">#include &lt;functional&gt;</span></span><br><span class="line">2、random_shuffle	洗牌，对指定范围内元素随机进行次序调整</span><br><span class="line">	random_shuffle(v.begin(), v.end())	给区间就可以</span><br><span class="line">3、merge		将两个容器的元素合并，并存储到另一容器中，两个容器必须是有序的，并且顺序一致</span><br><span class="line">	v3.resize(v1.size() + v2.size())		目标容器要提前分配空间</span><br><span class="line">	merge(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin())			</span><br><span class="line">4、reverse	反转指定范围的元素</span><br><span class="line">	reverse(v.begin(), v.end())	将区间内的元素反转</span><br><span class="line">常用拷贝和替换算法:</span><br><span class="line">1、copy		指定范围内元素拷贝到另一容器中</span><br><span class="line">	copy(v1.begin(), v1.end(), v2.begin())	要提前为v2分配内存</span><br><span class="line">2、replace	指定范围内旧元素替换为新元素</span><br><span class="line">	replace(v.begin(), v.end(), oldVal, newVal)</span><br><span class="line">3、replace_if	指定范围内满足条件的旧元素替换为新元素</span><br><span class="line">	replace_if(v.begin(), v.end(), GreaterFive(), newVal)		填入谓词（返回bool的仿函数）与新元素</span><br><span class="line">4、swap		互换两个容器的元素</span><br><span class="line">	swap(v1, v2)	放两个容器，要是同种类型的容器（比如说都是vector）</span><br><span class="line">常用算术生成算法:	<span class="comment">#include &lt;numeric&gt;</span></span><br><span class="line">1、accumulate	计算容器元素累计总和</span><br><span class="line">	accumulate(v.begin(), v.end(), 0)	返回一个int值，第三个参数是起始的累加值（填100，则从100开始加）</span><br><span class="line">2、fill		向容器中添加元素</span><br><span class="line">	fill(v.begin(), v.end(), value)		开始费带起，结束迭代器，添加的值</span><br><span class="line">常用集合算法:</span><br><span class="line">1、set_intersection	求两个容器的交集，两个容器必须是个有序序列，获取到交集后会返回交集的最后一个位置的迭代器</span><br><span class="line">	v3.resize(min(v1.size(), v2.size()))	分配空间时先两个集合较小的一个size就行，因为考虑到有包含关系的特殊交集存在</span><br><span class="line">	set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin())	</span><br><span class="line">2、set_union	求两个容器的并集，两个容器必须是个有序序列，获取到并集后会返回并集的最后一个位置的迭代器</span><br><span class="line">	v3.resize(v1.size() + v2.size())	分配空间时两个size相加，因为考虑到有可能元素完全不一样</span><br><span class="line">	set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin())</span><br><span class="line">3、set_difference	求两个容器的差集，v1与v2的差集（v1中不是v1与v2交集的部分叫差集）v2与v1的差集则是（v2中不是v1与v2交集的部分）</span><br><span class="line">	v3.resize(max(v1.size(), v2.size()))	分配目标容器为两个容器最大的一个的size</span><br><span class="line">	set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin())	两个容器必须是个有序序列，获取到差集后会返回差集的最后一个位置的迭代器</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">秋山澪</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/c++note/">http://example.com/c++note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">木风可可</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="http://yanxuan.nosdn.127.net/27ad4240afb3fa07197eaec257022c89.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="http://yanxuan.nosdn.127.net/300a62f2490c6f17d511841dcae1f924.jpg" target="_blank"><img class="post-qr-code-img" src="http://yanxuan.nosdn.127.net/300a62f2490c6f17d511841dcae1f924.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="http://yanxuan.nosdn.127.net/05d2ee6a16f637910d76d76eb1c3eca1.jpg" target="_blank"><img class="post-qr-code-img" src="http://yanxuan.nosdn.127.net/05d2ee6a16f637910d76d76eb1c3eca1.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/linux-note/"><img class="prev-cover" src="http://yanxuan.nosdn.127.net/77fafe855fffa4e29aa30b56af8af642.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux学习</div></div></a></div><div class="next-post pull-right"><a href="/autocad-note/"><img class="next-cover" src="https://s1.ax1x.com/2020/11/10/BL2zDJ.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">AutoCAD学习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/autocad-note/" title="AutoCAD学习"><img class="cover" src="https://s1.ax1x.com/2020/11/10/BL2zDJ.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-03</div><div class="title">AutoCAD学习</div></div></a></div><div><a href="/ad-note/" title="AltiumDesigner学习"><img class="cover" src="http://yanxuan.nosdn.127.net/986042e56f5523fc4bff794e4b6c4586.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-30</div><div class="title">AltiumDesigner学习</div></div></a></div><div><a href="/git-used/" title="GIT使用笔记"><img class="cover" src="https://s1.ax1x.com/2020/07/19/UWJuZR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-19</div><div class="title">GIT使用笔记</div></div></a></div><div><a href="/golang-note/" title="go语言学习"><img class="cover" src="http://yanxuan.nosdn.127.net/8f4f53c328ba7a1e1b8d98fb0129463a.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-09</div><div class="title">go语言学习</div></div></a></div><div><a href="/linux-note/" title="Linux学习"><img class="cover" src="http://yanxuan.nosdn.127.net/77fafe855fffa4e29aa30b56af8af642.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-03</div><div class="title">Linux学习</div></div></a></div><div><a href="/Qt-note/" title="Qt学习笔记"><img class="cover" src="https://s1.ax1x.com/2020/07/19/UWJDW8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-19</div><div class="title">Qt学习笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s1.ax1x.com/2020/10/17/0LTXFK.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">秋山澪</div><div class="author-info__description">木风可可的博客</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sorrowfeng"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">木风可可的个人小站</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#vs%E6%B3%A8%E9%87%8A%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">1.</span> <span class="toc-text">vs注释快捷键</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%87%BA-cout"><span class="toc-number">2.</span> <span class="toc-text">数据的输出:cout</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">定义常量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sizeof-%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%89%80%E5%8D%A0%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="toc-number">4.</span> <span class="toc-text">sizeof 统计数据类型所占的内存大小</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">整型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">浮点型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9E%8B"><span class="toc-number">7.</span> <span class="toc-text">字符串型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">布尔型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">科学计数法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">10.</span> <span class="toc-text">转义字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%85%A5-cin"><span class="toc-number">11.</span> <span class="toc-text">数据的输入:cin</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5"><span class="toc-number">12.</span> <span class="toc-text">跳转语句:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">13.</span> <span class="toc-text">头文件:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">14.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88"><span class="toc-number">14.1.</span> <span class="toc-text">野指针:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88"><span class="toc-number">14.2.</span> <span class="toc-text">常量指针:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="toc-number">14.3.</span> <span class="toc-text">指针常量:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84"><span class="toc-number">14.4.</span> <span class="toc-text">指针指向数组:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">15.</span> <span class="toc-text">结构体:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#system%E5%91%BD%E4%BB%A4"><span class="toc-number">16.</span> <span class="toc-text">system命令:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E4%B8%AA%E5%88%86%E5%8C%BA"><span class="toc-number">17.</span> <span class="toc-text">四个分区:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#new%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">18.</span> <span class="toc-text">new关键字:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">19.</span> <span class="toc-text">引用:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">20.</span> <span class="toc-text">函数:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0"><span class="toc-number">21.</span> <span class="toc-text">函数占位参数:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">22.</span> <span class="toc-text">函数重载:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">23.</span> <span class="toc-text">封装:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">24.</span> <span class="toc-text">封装的访问权限:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8c-%E4%B8%ADstruct%E4%B8%8Eclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">25.</span> <span class="toc-text">在c++中struct与class的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%89"><span class="toc-number">26.</span> <span class="toc-text">构造函数（初始化）:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%88%E6%B8%85%E7%90%86%EF%BC%89"><span class="toc-number">27.</span> <span class="toc-text">析构函数（清理）:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">28.</span> <span class="toc-text">拷贝构造函数:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">29.</span> <span class="toc-text">构造函数的调用:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-number">30.</span> <span class="toc-text">拷贝构造函数的使用时机:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">31.</span> <span class="toc-text">构造函数调用规则:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">32.</span> <span class="toc-text">深拷贝与浅拷贝:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">33.</span> <span class="toc-text">初始化列表:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">34.</span> <span class="toc-text">类对象作为类成员:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">35.</span> <span class="toc-text">静态成员:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">36.</span> <span class="toc-text">this指针:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">37.</span> <span class="toc-text">空指针调用成员函数:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">38.</span> <span class="toc-text">const修饰成员函数:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">39.</span> <span class="toc-text">友元:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">40.</span> <span class="toc-text">运算符重载:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">41.</span> <span class="toc-text">继承:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8vs%E5%B7%A5%E5%85%B7%E4%B8%AD%E6%9F%A5%E7%9C%8B%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%88VS-2017%E7%9A%84%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6%EF%BC%89"><span class="toc-number">42.</span> <span class="toc-text">在vs工具中查看类的对象模型（VS 2017的开发人员工具命令提示符）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">43.</span> <span class="toc-text">继承中构造和析构的顺序:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">44.</span> <span class="toc-text">继承中同名成员处理方式:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">45.</span> <span class="toc-text">继承同名静态成员处理方式:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span class="toc-number">46.</span> <span class="toc-text">多继承语法:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="toc-number">47.</span> <span class="toc-text">菱形继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">48.</span> <span class="toc-text">重写与重载的区别:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">49.</span> <span class="toc-text">多态:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">50.</span> <span class="toc-text">纯虚函数和抽象类:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84"><span class="toc-number">51.</span> <span class="toc-text">虚析构和纯虚析构:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-%E5%AF%B9%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E8%A6%81%E5%8A%A0-include"><span class="toc-number">52.</span> <span class="toc-text">文件操作:对文件操作要加#include </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">53.</span> <span class="toc-text">模板:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">54.</span> <span class="toc-text">普通函数与函数模板的调用规则:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95"><span class="toc-number">55.</span> <span class="toc-text">类模板语法:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">56.</span> <span class="toc-text">类模板与函数模板的区别:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA"><span class="toc-number">57.</span> <span class="toc-text">类模板中成员函数的创建时机:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">58.</span> <span class="toc-text">查看模板参数类型:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AF%B9%E8%B1%A1%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">59.</span> <span class="toc-text">类模板对象做函数参数:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">60.</span> <span class="toc-text">类模板与继承:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%B1%BB%E5%A4%96%E5%AE%9E%E7%8E%B0"><span class="toc-number">61.</span> <span class="toc-text">类模板的成员函数类外实现:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99"><span class="toc-number">62.</span> <span class="toc-text">类模板的分文件编写:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%8F%8B%E5%85%83"><span class="toc-number">63.</span> <span class="toc-text">类模板与友元:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL"><span class="toc-number">64.</span> <span class="toc-text">STL:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vector%E5%AE%B9%E5%99%A8-include-%E5%8C%85%E5%90%AB%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">65.</span> <span class="toc-text">vector容器:#include 	包含头文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vector%E5%AE%B9%E5%99%A8%E5%B5%8C%E5%A5%97%E5%AE%B9%E5%99%A8"><span class="toc-number">66.</span> <span class="toc-text">vector容器嵌套容器:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#string%E5%AE%B9%E5%99%A8"><span class="toc-number">67.</span> <span class="toc-text">string容器:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vector%E5%AE%B9%E5%99%A8"><span class="toc-number">68.</span> <span class="toc-text">vector容器:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#deque%E5%AE%B9%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%94%AF%E6%8C%81%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE"><span class="toc-number">69.</span> <span class="toc-text">deque容器:迭代器支持随机访问</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-number">70.</span> <span class="toc-text">随机数的获取:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#stack%E5%AE%B9%E5%99%A8"><span class="toc-number">71.</span> <span class="toc-text">stack容器:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#queue%E5%AE%B9%E5%99%A8"><span class="toc-number">72.</span> <span class="toc-text">queue容器:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#list%E5%AE%B9%E5%99%A8"><span class="toc-number">73.</span> <span class="toc-text">list容器:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#set-x2F-multiset%E5%AE%B9%E5%99%A8-%E9%83%BD%E6%98%AF%E5%8C%85%E5%90%AB-include"><span class="toc-number">74.</span> <span class="toc-text">set&#x2F;multiset容器:都是包含#include</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pair%E5%AF%B9%E7%BB%84"><span class="toc-number">75.</span> <span class="toc-text">pair对组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#map-x2F-multimap%E5%AE%B9%E5%99%A8"><span class="toc-number">76.</span> <span class="toc-text">map&#x2F;multimap容器:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">77.</span> <span class="toc-text">函数对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%93%E8%AF%8D"><span class="toc-number">78.</span> <span class="toc-text">谓词:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-include"><span class="toc-number">79.</span> <span class="toc-text">内建函数对象:#include </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="toc-number">80.</span> <span class="toc-text">STL常用算法:</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/qt-with-opencv/" title="Qt配置opencv环境"><img src="https://s1.ax1x.com/2020/08/02/ate2E6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qt配置opencv环境"/></a><div class="content"><a class="title" href="/qt-with-opencv/" title="Qt配置opencv环境">Qt配置opencv环境</a><time datetime="2020-08-02T10:22:51.000Z" title="发表于 2020-08-02 18:22:51">2020-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/git-used/" title="GIT使用笔记"><img src="https://s1.ax1x.com/2020/07/19/UWJuZR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GIT使用笔记"/></a><div class="content"><a class="title" href="/git-used/" title="GIT使用笔记">GIT使用笔记</a><time datetime="2020-07-19T10:29:59.000Z" title="发表于 2020-07-19 18:29:59">2020-07-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Qt-note/" title="Qt学习笔记"><img src="https://s1.ax1x.com/2020/07/19/UWJDW8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qt学习笔记"/></a><div class="content"><a class="title" href="/Qt-note/" title="Qt学习笔记">Qt学习笔记</a><time datetime="2020-07-19T09:38:50.000Z" title="发表于 2020-07-19 17:38:50">2020-07-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/spider-comic/" title="python爬取漫画网站"><img src="http://yanxuan.nosdn.127.net/bb8aaf99bd11f0eb934431477caecda6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="python爬取漫画网站"/></a><div class="content"><a class="title" href="/spider-comic/" title="python爬取漫画网站">python爬取漫画网站</a><time datetime="2020-05-27T05:58:41.000Z" title="发表于 2020-05-27 13:58:41">2020-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/spider-novels-thread/" title="python爬取小说多线程版本"><img src="http://yanxuan.nosdn.127.net/21a929d6d313be9954b494a502d99764.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="python爬取小说多线程版本"/></a><div class="content"><a class="title" href="/spider-novels-thread/" title="python爬取小说多线程版本">python爬取小说多线程版本</a><time datetime="2020-05-24T13:43:00.000Z" title="发表于 2020-05-24 21:43:00">2020-05-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 秋山澪</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>