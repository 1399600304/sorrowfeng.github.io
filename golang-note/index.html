<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>go语言学习 | 木风可可</title><meta name="keywords" content="学习笔记,Golang"><meta name="author" content="秋山澪"><meta name="copyright" content="秋山澪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="go语言中不用写分号Hello Worldpackage main&#x2F;&#x2F;导入语句import &quot;fmt&quot;&#x2F;&#x2F;函数外只能放置标识符的声明&#x2F;&#x2F;程序的入口函数func main() &amp;#123;    fmt.Println(&quot;hello,world!&quot;)&amp;#125;  前言在cmd中输入go version可以查看版本号在项目目录下执行go build编译文件在其">
<meta property="og:type" content="article">
<meta property="og:title" content="go语言学习">
<meta property="og:url" content="http://example.com/golang-note/index.html">
<meta property="og:site_name" content="木风可可">
<meta property="og:description" content="go语言中不用写分号Hello Worldpackage main&#x2F;&#x2F;导入语句import &quot;fmt&quot;&#x2F;&#x2F;函数外只能放置标识符的声明&#x2F;&#x2F;程序的入口函数func main() &amp;#123;    fmt.Println(&quot;hello,world!&quot;)&amp;#125;  前言在cmd中输入go version可以查看版本号在项目目录下执行go build编译文件在其">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yanxuan.nosdn.127.net/8f4f53c328ba7a1e1b8d98fb0129463a.jpg">
<meta property="article:published_time" content="2020-04-09T12:59:19.000Z">
<meta property="article:modified_time" content="2020-11-10T11:27:53.308Z">
<meta property="article:author" content="秋山澪">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="Golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yanxuan.nosdn.127.net/8f4f53c328ba7a1e1b8d98fb0129463a.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/golang-note/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'go语言学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-11-10 19:27:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s1.ax1x.com/2020/10/17/0LTXFK.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://yanxuan.nosdn.127.net/8f4f53c328ba7a1e1b8d98fb0129463a.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">木风可可</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">go语言学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-04-09T12:59:19.000Z" title="发表于 2020-04-09 20:59:19">2020-04-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-11-10T11:27:53.308Z" title="更新于 2020-11-10 19:27:53">2020-11-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="go语言学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="go语言中不用写分号"><a href="#go语言中不用写分号" class="headerlink" title="go语言中不用写分号"></a>go语言中不用写分号</h1><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">//导入语句</span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line">//函数外只能放置标识符的声明</span><br><span class="line">//程序的入口函数</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello,world!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在cmd中输入go version可以查看版本号</span><br><span class="line"></span><br><span class="line">在项目目录下执行go build编译文件</span><br><span class="line">在其他路径下后面加上项目的路径，路径从GOPATH\src后面写起</span><br><span class="line"></span><br><span class="line">go build -o helloworld.exe 可以自己决定生成exe文件的名字</span><br><span class="line"></span><br><span class="line">go run main.go执行，不推荐</span><br></pre></td></tr></table></figure>

<h1 id="跨平台编译"><a href="#跨平台编译" class="headerlink" title="跨平台编译"></a>跨平台编译</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">只需要指定目标操作系统的平台和处理器架构</span><br><span class="line">SET CGO_ENABLED=0  // 禁用CGO</span><br><span class="line">SET GOOS=linux  // 目标平台是linux</span><br><span class="line">SET GOARCH=amd64  // 目标处理器架构是amd64</span><br></pre></td></tr></table></figure>


<h1 id="变量声明，go语言中变量必须先声明再使用"><a href="#变量声明，go语言中变量必须先声明再使用" class="headerlink" title="变量声明，go语言中变量必须先声明再使用"></a>变量声明，go语言中变量必须先声明再使用</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var 变量名称 变量类型</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line">var s1 string</span><br><span class="line">var num int</span><br><span class="line">var s2 = <span class="string">&quot;sss&quot;</span> //声明的同时赋值</span><br><span class="line">//批量声明</span><br><span class="line">var (</span><br><span class="line">    name string //<span class="string">&quot;&quot;</span></span><br><span class="line">    age  int    //0</span><br><span class="line">    sex  bool   //false</span><br><span class="line">)</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    //变量的初始化</span><br><span class="line">    name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">    age = 20</span><br><span class="line">    sex = <span class="literal">true</span></span><br><span class="line">    //go语言中变量声明了必须使用，不然编译失败</span><br><span class="line">    fmt.Print(sex)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;name:%s\n&quot;</span>, name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;age:&quot;</span>, age)</span><br><span class="line">	//简短变量声明，只能在函数内部使用</span><br><span class="line">    s3 := <span class="string">&quot;string&quot;</span></span><br><span class="line">    fmt.Println(s3)</span><br><span class="line">    //匿名变量，用一个单独的下划线来表示，_</span><br><span class="line">    //用于多重赋值忽略某个参数，如下有两个返回值只想取其中一个</span><br><span class="line">    x, _ = <span class="keyword">function</span>()</span><br><span class="line">    _, y = <span class="keyword">function</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//常量的定义</span><br><span class="line">//定义了常量之后不能再修改了</span><br><span class="line">const pi = 3.1415926535</span><br><span class="line">const (</span><br><span class="line">    n1 = <span class="string">&quot;lisi&quot;</span></span><br><span class="line">    n2          //如果省略则与上一行相同</span><br><span class="line">    a1 = 100</span><br><span class="line">    a2</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="iota-ota是go语言的常量计数器，只能在常量的表达式中使用。"><a href="#iota-ota是go语言的常量计数器，只能在常量的表达式中使用。" class="headerlink" title="iota:ota是go语言的常量计数器，只能在常量的表达式中使用。"></a>iota:ota是go语言的常量计数器，只能在常量的表达式中使用。</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iota是go语言的常量计数器，只能在常量的表达式中使用。</span><br><span class="line">iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</span><br><span class="line"></span><br><span class="line">//使用_跳过某些值</span><br><span class="line">const (</span><br><span class="line">    n1 = iota //0</span><br><span class="line">    n2        //1</span><br><span class="line">    _</span><br><span class="line">    n4        //3</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//iota声明中间插队</span><br><span class="line">const (</span><br><span class="line">    n1 = iota //0</span><br><span class="line">    n2 = 100  //100</span><br><span class="line">    n3 = iota //2</span><br><span class="line">    n4        //3</span><br><span class="line">)</span><br><span class="line">const n5 = iota //0</span><br><span class="line"></span><br><span class="line">//多个iota定义在一行</span><br><span class="line">const (</span><br><span class="line">    a, b = iota + 1, iota + 2 //1,2</span><br><span class="line">    c, d                      //2,3</span><br><span class="line">    e, f                      //3,4</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//定义数量级 （1左移10位，变成了10000000000，也就是十进制的1024。）</span><br><span class="line">const (</span><br><span class="line">    _  = iota             //0，不要</span><br><span class="line">    KB = 1 &lt;&lt; (10 * iota) //10000000000 ----- 1024</span><br><span class="line">    MB = 1 &lt;&lt; (10 * iota) //1 &lt;&lt; <span class="string">20     1左移20</span>位</span><br><span class="line">    GB = 1 &lt;&lt; (10 * iota)</span><br><span class="line">    TB = 1 &lt;&lt; (10 * iota)</span><br><span class="line">    PB = 1 &lt;&lt; (10 * iota)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go语言中不能定义二进制数，需要定义只能强制转换</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line">var (</span><br><span class="line">    n1 = 101    //十进制</span><br><span class="line">    n2 = 077    //八进制，前面加0</span><br><span class="line">    n3 = 0xff   //十六进制，前面加0x</span><br><span class="line">)</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;十进制     n1:%d\n&quot;</span>, n1) //十进制输出%d，101</span><br><span class="line">    fmt.Printf(<span class="string">&quot;二进制     n1:%b\n&quot;</span>, n1) //转为二进制%b，1100101</span><br><span class="line">    fmt.Printf(<span class="string">&quot;八进制     n1:%o\n&quot;</span>, n1) //转为八进制%o，145</span><br><span class="line">    fmt.Printf(<span class="string">&quot;十六进制    n1:%x\n&quot;</span>, n1) //转为十六进制%x，65</span><br><span class="line">    fmt.Printf(<span class="string">&quot;十进制     n2:%d\n&quot;</span>, n2) //63</span><br><span class="line">    fmt.Printf(<span class="string">&quot;十进制     n3:%d\n&quot;</span>, n3) //255</span><br><span class="line">	//声明一个uint8类型的变量</span><br><span class="line">    n4 := uint8(20)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;n4:%T\n&quot;</span>, n4) //查看变量的类型%T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型:"></a>浮点型:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">默认go语言中小数都是float64类型的</span><br><span class="line">不同类型不能直接赋值，float64与float32是完全不同的两个类型</span><br><span class="line"></span><br><span class="line">复数:complex64和complex128</span><br></pre></td></tr></table></figure>

<h1 id="bool型"><a href="#bool型" class="headerlink" title="bool型:"></a>bool型:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bool类型默认值为<span class="literal">false</span></span><br><span class="line">不允许将整型强制转换为bool类型</span><br><span class="line">bool类型不能参与运算</span><br><span class="line"></span><br><span class="line">var value bool</span><br><span class="line">fmt.Printf(<span class="string">&quot;value:%v\n&quot;</span>, value) //%v是value的缩写，不管什么类型都能打印出来，打印出<span class="literal">false</span>，bool值默认为<span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">字符串是以双引号来包裹的，字符以单引号来包裹（单独的字母、汉字、符号表示一个字符）</span><br><span class="line">一个字符 <span class="string">&#x27;A&#x27;</span> = 1个字节</span><br><span class="line">一个utf8的汉字 <span class="string">&#x27;我&#x27;</span> = 一般占3个字节</span><br><span class="line">UNcode编码一个汉字一般占2个字节</span><br></pre></td></tr></table></figure>

<h1 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\r  回车符（返回行首）</span><br><span class="line">    \n  换行符（直接跳到下一行的同列位置）</span><br><span class="line">    \t  制表符</span><br><span class="line">    \<span class="string">&#x27;  单引号</span></span><br><span class="line"><span class="string">    \&quot;  双引号</span></span><br><span class="line"><span class="string">    \\  反斜杠</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h1 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Go语言中要定义一个多行字符串时，就必须使用反引号字符:</span><br><span class="line"></span><br><span class="line">//写在两个反引号之间的内容会原样输出</span><br><span class="line">s1 := `第一行</span><br><span class="line">    第二行</span><br><span class="line">    第三行</span><br><span class="line">    `</span><br><span class="line">    fmt.Println(s1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="strings常用函数"><a href="#strings常用函数" class="headerlink" title="strings常用函数"></a>strings常用函数</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">len(str)	求长度</span><br><span class="line">fmt.Println(len(ss4))                //len求长度</span><br><span class="line"></span><br><span class="line">+或fmt.Sprintf	拼接字符串</span><br><span class="line">ss3 := ss1 + ss2                     //用+拼接字符串</span><br><span class="line">ss4 := fmt.Sprintf(<span class="string">&quot;%s%s&quot;</span>, ss1, ss2) //用sprintf函数拼接</span><br><span class="line"></span><br><span class="line">strings.Split	分割</span><br><span class="line">fmt.Println(strings.Split(ss1, <span class="string">&quot;m&quot;</span>)) //分隔，将name以m分隔开来，输出结果:[na e:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">strings.Contains	判断是否包含</span><br><span class="line">states := strings.Contains(ss1, <span class="string">&quot;m&quot;</span>) //ss1是否包含m，返回bool类型，输出结果:<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">strings.HasPrefix,strings.HasSuffix	前缀/后缀判断</span><br><span class="line">states = strings.HasPrefix(ss1, <span class="string">&quot;n&quot;</span>) //前缀判断</span><br><span class="line">states = strings.HasSuffix(ss1, <span class="string">&quot;n&quot;</span>) //后缀判断</span><br><span class="line"></span><br><span class="line">strings.Index(),strings.LastIndex()	子串出现的位置</span><br><span class="line">num := strings.Index(ss1, <span class="string">&quot;e&quot;</span>) //返回子串出现的位置</span><br><span class="line">num = strings.LastIndex(ss4, <span class="string">&quot;a&quot;</span>) //返回子串最后一次出现的位置</span><br><span class="line"></span><br><span class="line">strings.Join(a[]string, sep string)	<span class="built_in">join</span>操作</span><br><span class="line">fmt.Println(strings.Join(ss5, <span class="string">&quot;A&quot;</span>)) //实现了拼接的功能，用A将分隔开来的ss5连接起来</span><br></pre></td></tr></table></figure>

<h1 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var a := <span class="string">&#x27;中&#x27;</span></span><br><span class="line">var b := <span class="string">&#x27;x&#x27;</span></span><br><span class="line"></span><br><span class="line">Go 语言的字符有以下两种:</span><br><span class="line">	1. uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。</span><br><span class="line">	2. rune类型，代表一个 UTF-8字符。</span><br><span class="line">当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="遍历字符串两种方法"><a href="#遍历字符串两种方法" class="headerlink" title="遍历字符串两种方法"></a>遍历字符串两种方法</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 遍历字符串</span><br><span class="line">func <span class="function"><span class="title">traversalString</span></span>() &#123;</span><br><span class="line">    s := <span class="string">&quot;hello你好&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i := 0; i &lt; len(s); i++ &#123; //byte</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v(%c) &quot;</span>, s[i], s[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    <span class="keyword">for</span> _, r := range s &#123; //rune</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v(%c) &quot;</span>, r, r)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。</span><br><span class="line">因为字符串本身是不可修改的</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">changeString</span></span>() &#123;</span><br><span class="line">    s1 := <span class="string">&quot;big&quot;</span></span><br><span class="line">    // 强制类型转换</span><br><span class="line">    byteS1 := []byte(s1)</span><br><span class="line">    byteS1[0] = <span class="string">&#x27;p&#x27;</span></span><br><span class="line">    fmt.Println(string(byteS1))</span><br><span class="line">    s2 := <span class="string">&quot;白萝卜&quot;</span></span><br><span class="line">    runeS2 := []rune(s2)</span><br><span class="line">    runeS2[0] = <span class="string">&#x27;红&#x27;</span></span><br><span class="line">    fmt.Println(string(runeS2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</span><br><span class="line">强制类型转换的基本语法如下:</span><br><span class="line"></span><br><span class="line">float64(a*a + b*b)</span><br></pre></td></tr></table></figure>

<h1 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">注意: ++（自增）和--（自减）在Go语言中是单独的语句，并不是运算符。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><h2 id="切片的定义和初始化"><a href="#切片的定义和初始化" class="headerlink" title="切片的定义和初始化"></a>切片的定义和初始化</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//切片的定义和初始化</span><br><span class="line">    var a []string</span><br><span class="line">    var b = []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    fmt.Println(b)</span><br><span class="line">    //基于数组定义切片</span><br><span class="line">    var intArray = [5]int&#123;10, 20, 30, 40, 50&#125;</span><br><span class="line">    var intSlice = intArray[1:3] //左闭右开，左右省略分别表示0和切片操作数的长度</span><br><span class="line">    //[:4]表示[0:4],  [2:]表示[2:len(intArray)]</span><br><span class="line">    fmt.Println(intArray)</span><br><span class="line">    fmt.Println(intSlice)</span><br><span class="line">    A := [5]int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">    t := A[1:3:5] //切片的完整表示方法，a[low : high : max]，切片的容量<span class="built_in">cap</span>设置为max-low</span><br><span class="line">    fmt.Println(A)</span><br><span class="line">    fmt.Println(t)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//构建长度为5,容量为10的int型切片，可以用len获取长度，用<span class="built_in">cap</span>获取容量</span><br><span class="line">    slice := make([]int, 5, 10) //注意构建的不为空， 因为给了长度是5， int默认填充00000</span><br><span class="line">    fmt.Println(slice)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用append-函数添加元素"><a href="#使用append-函数添加元素" class="headerlink" title="使用append()函数添加元素"></a>使用append()函数添加元素</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//判断切片是否为空,使用len(slice) == 0</span><br><span class="line">    <span class="keyword">if</span> len(slice) == 5 &#123;</span><br><span class="line">        slice = append(slice, 100)	//注意用原切片去接收，因为append是可以动态扩充的，容量不够时回自动扩充,在另一片地址重新构建一个切片</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(slice) //append在后面追加元素[0 0 0 0 0 100]</span><br><span class="line">    //切片的赋值拷贝，拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容</span><br><span class="line">    slice2 := slice //直接将slice赋值拷贝给slice2</span><br><span class="line">    fmt.Println(slice) //[0 0 0 0 0 100]</span><br><span class="line">    fmt.Println(slice2)</span><br><span class="line">    slice2[0] = 50</span><br><span class="line">    fmt.Println(slice) //两个都被同时修改了，[50 0 0 0 0 100]</span><br><span class="line">    fmt.Println(slice2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用copy函数赋值切片，避免直接赋值共用一块内存的问题"><a href="#使用copy函数赋值切片，避免直接赋值共用一块内存的问题" class="headerlink" title="使用copy函数赋值切片，避免直接赋值共用一块内存的问题"></a>使用copy函数赋值切片，避免直接赋值共用一块内存的问题</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//用copy函数可以避免这个问题，让两个分别对应两块不同的内存</span><br><span class="line">    //var slice3 = []int&#123;0, 0, 0, 0, 0, 0&#125;</span><br><span class="line">    slice3 := make([]int, 6, 10)</span><br><span class="line">    copy(slice3, slice)</span><br><span class="line">    slice3[1] = 66</span><br><span class="line">    fmt.Println(slice)  //[50 0 0 0 0 100]</span><br><span class="line">    fmt.Println(slice3) //[50 66 0 0 0 100] 不会同时修改</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="切片删除元素，利用append函数"><a href="#切片删除元素，利用append函数" class="headerlink" title="切片删除元素，利用append函数"></a>切片删除元素，利用append函数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  //本身没有删除元素的函数，可以利用append函数实现</span><br><span class="line">    slice4 := make([]int, 6, 10)</span><br><span class="line">    copy(slice4, slice3)</span><br><span class="line">    fmt.Println(slice4)                        //[50 66 0 0 0 100]</span><br><span class="line">    slice4 = append(slice4[:0], slice4[1:]...) //必须要加上...</span><br><span class="line">    fmt.Println(slice4)                        //[66 0 0 0 100] 删除了第0号元素</span><br><span class="line">    //总结:要从切片a中删除索引为index的元素，操作方法是a = append(a[:index], a[index+1:]...)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="判断切片是否为空"><a href="#判断切片是否为空" class="headerlink" title="判断切片是否为空"></a>判断切片是否为空</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 要检查切片是否为空，请始终使用len(s) == 0来判断，而不应该使用s == nil来判断。</span><br><span class="line">nil代表切片的0值，只有在切片声明但并未初始化，才有slice==nil</span><br><span class="line">var slice []int         //len(s1)=0;<span class="built_in">cap</span>(s1)=0;s1==nil</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="切片不能直接比较"><a href="#切片不能直接比较" class="headerlink" title="切片不能直接比较"></a>切片不能直接比较</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 切片之间是不能比较的，我们不能使用==操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和nil比较。 一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是nil，例如下面的示例:</span><br><span class="line">var s1 []int         //len(s1)=0;<span class="built_in">cap</span>(s1)=0;s1==nil</span><br><span class="line">s2 := []int&#123;&#125;        //len(s2)=0;<span class="built_in">cap</span>(s2)=0;s2!=nil</span><br><span class="line">s3 := make([]int, 0) //len(s3)=0;<span class="built_in">cap</span>(s3)=0;s3!=nil</span><br></pre></td></tr></table></figure>

<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><h2 id="map的定义"><a href="#map的定义" class="headerlink" title="map的定义"></a>map的定义</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//map的定义，map里的元素都是成对的</span><br><span class="line">    scoreMap := make(map[string]int, 10) //初始化并设置容量</span><br><span class="line">//map的初始化，map里的元素都是成对的</span><br><span class="line">    scoreMap[<span class="string">&quot;张三&quot;</span>] = 90</span><br><span class="line">    scoreMap[<span class="string">&quot;李四&quot;</span>] = 100</span><br><span class="line">    scoreMap[<span class="string">&quot;王五&quot;</span>] = 60</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="用for-range的遍历方法遍历map"><a href="#用for-range的遍历方法遍历map" class="headerlink" title="用for range的遍历方法遍历map"></a>用for range的遍历方法遍历map</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := range scoreMap &#123; </span><br><span class="line">        fmt.Println(k)</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> k := range scoreMap &#123; //只需要遍历key时，可以省略对应value的_</span><br><span class="line">        fmt.Println(k) //仅限遍历key， 如果省略不写默认接收key</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, value := range scoreMap &#123; //遍历value时需要接收两个</span><br><span class="line">        fmt.Println(value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="判断某个键是否存在"><a href="#判断某个键是否存在" class="headerlink" title="判断某个键是否存在"></a>判断某个键是否存在</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   value, ok := scoreMap[<span class="string">&quot;张三&quot;</span>] //判断是否有key:张三的存在，存在ok为<span class="literal">true</span>并将key对应的值传入value中，</span><br><span class="line">    <span class="keyword">if</span> ok &#123;                     //否则为<span class="literal">false</span>并传入value类型的零值</span><br><span class="line">        fmt.Println(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用delete删除键值对"><a href="#使用delete删除键值对" class="headerlink" title="使用delete删除键值对"></a>使用delete删除键值对</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">delete(scoreMap, <span class="string">&quot;娜扎&quot;</span>) //删除key为娜扎的键值对</span><br><span class="line">    fmt.Println(scoreMap)</span><br></pre></td></tr></table></figure>

<h2 id="在声明的同时填充元素"><a href="#在声明的同时填充元素" class="headerlink" title="在声明的同时填充元素"></a>在声明的同时填充元素</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> userInfo := map[string]string&#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: <span class="string">&quot;plf&quot;</span>,</span><br><span class="line">        <span class="string">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(userInfo)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="随机数的使用方法"><a href="#随机数的使用方法" class="headerlink" title="随机数的使用方法"></a>随机数的使用方法</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  rand.Seed(time.Now().UnixNano()) //初始化随机数种子</span><br><span class="line">    <span class="keyword">for</span> i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">        num := rand.Intn(100) //生成0~99的随机整数</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//指针</span><br><span class="line">func swap(x *int, y *int) &#123;</span><br><span class="line">    temp := *x</span><br><span class="line">    *x = *y</span><br><span class="line">    *y = temp</span><br><span class="line">&#125;</span><br><span class="line">swap(&amp;x, &amp;y)</span><br><span class="line">//没有引用的用法 error</span><br><span class="line">// func swap2(x &amp;int, y &amp;int) &#123;</span><br><span class="line">//  temp := x</span><br><span class="line">//  x = y</span><br><span class="line">//  y = temp</span><br><span class="line">// &#125;</span><br><span class="line">func <span class="built_in">sum</span>(x, y int) int &#123;</span><br><span class="line">    <span class="built_in">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//go语言中没有默认参数</span><br><span class="line">//可以同时接收固定参数和可变参数， 可变参数要放在最后</span><br><span class="line">//形参接收可变参数，字后面加...， 参数是个切片类型</span><br><span class="line">func sumAny(a ...int) int &#123;</span><br><span class="line">    result := 0</span><br><span class="line">    <span class="keyword">for</span> _, value := range a &#123; //go中默认接收两个值， 下标和值， 只写一个默认接收下标， 在map中接收的则是key</span><br><span class="line">        result += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//在defer归属的函数即将返回时，先被defer的语句最后被执行，最后被defer的语句，最先被执行。</span><br><span class="line">    fmt.Println(10)</span><br><span class="line">    defer fmt.Println(1) </span><br><span class="line">    defer fmt.Println(2)</span><br><span class="line">    defer fmt.Println(3)</span><br><span class="line">    fmt.Println(20)</span><br><span class="line">//执行顺序 10， 20， 3， 2， 1</span><br></pre></td></tr></table></figure>

<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func myFunc(name string) <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">    //外层变量(形参中)</span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">func</span></span>() &#123; //返回了一个匿名函数</span><br><span class="line">        fmt.Println(<span class="string">&quot;hello&quot;</span>, name) //引用了外层变量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//闭包 = 函数 + 外层变量的引用</span><br><span class="line">ret := myFunc(<span class="string">&quot;plf&quot;</span>) //ret就是一个闭包</span><br><span class="line">ret()           //执行了返回的匿名函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="闭包实例"><a href="#闭包实例" class="headerlink" title="闭包实例"></a>闭包实例</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//加后缀的函数</span><br><span class="line">func addSuffix(suffix string) func(string) string &#123;</span><br><span class="line">    <span class="built_in">return</span> func(name string) string &#123;</span><br><span class="line">        <span class="keyword">if</span> !strings.HasSuffix(name, suffix) &#123; //如果后缀不是suffix就为name加上suffix，否则返回name</span><br><span class="line">            <span class="built_in">return</span> name + suffix</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">res := addSuffix(<span class="string">&quot;.avi&quot;</span>) //输入suffix的值， 并返回匿名函数， 此时res为一个闭包 </span><br><span class="line">temp := res(<span class="string">&quot;nihao&quot;</span>)     //输入name的值， 并返回加后缀后的结果</span><br><span class="line">fmt.Println(temp)        //打印结果</span><br></pre></td></tr></table></figure>

<h1 id="panir-x2F-recover异常处理"><a href="#panir-x2F-recover异常处理" class="headerlink" title="panir&#x2F;recover异常处理"></a>panir&#x2F;recover异常处理</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//recover()必须搭配defer使用。defer一定要在可能引发panic的语句之前定义。</span><br><span class="line">func <span class="function"><span class="title">b</span></span>() &#123;</span><br><span class="line">    defer <span class="function"><span class="title">func</span></span>() &#123; //必须写在发生异常的前面</span><br><span class="line">        err := recover() //接收错误信息</span><br><span class="line">        <span class="keyword">if</span> err != nil &#123;  //不为空则说明发生了异常</span><br><span class="line">            fmt.Println(<span class="string">&quot;b error&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    panic(<span class="string">&quot;panic b&quot;</span>) //报异常</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//&amp;取出地址，*根据地址取出地址指向的值</span><br><span class="line">func swap(x, y *int) &#123;</span><br><span class="line">    temp := *x</span><br><span class="line">    *x = *y</span><br><span class="line">    *y = temp</span><br><span class="line">&#125;</span><br><span class="line">swap(&amp;x, &amp;y)</span><br><span class="line">fmt.Println(x, y</span><br></pre></td></tr></table></figure>

<h1 id="new开辟内存"><a href="#new开辟内存" class="headerlink" title="new开辟内存"></a>new开辟内存</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    p := new(int) //new开辟内存， 并把对应内存的地址返回</span><br><span class="line">    fmt.Println(p)</span><br><span class="line">    fmt.Println(*p)</span><br><span class="line">    *p = 999</span><br><span class="line">    fmt.Println(p)</span><br><span class="line">    fmt.Println(*p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</span><br><span class="line">//而make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</span><br></pre></td></tr></table></figure>


<h1 id="自定义类型与取别名"><a href="#自定义类型与取别名" class="headerlink" title="自定义类型与取别名"></a>自定义类型与取别名</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//自定义类型</span><br><span class="line"></span><br><span class="line">//MyInt the <span class="built_in">type</span> of int</span><br><span class="line"><span class="built_in">type</span> MyInt int //要写上注释， 否则会警告， 名字是大写的时候</span><br><span class="line"></span><br><span class="line">//类型别名</span><br><span class="line"></span><br><span class="line">//Byte the <span class="built_in">type</span> of uint8</span><br><span class="line"><span class="built_in">type</span> Byte = uint8</span><br><span class="line"></span><br><span class="line">var x MyInt</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T, %d\n&quot;</span>, x, x) //main.MyInt, 0</span><br><span class="line">var y Byte</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T, %d\n&quot;</span>, y, y) //uint8, 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//结构体定义</span><br><span class="line"><span class="built_in">type</span> person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    age  int</span><br><span class="line">    sex  string</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="结构体的初始化"><a href="#结构体的初始化" class="headerlink" title="结构体的初始化"></a>结构体的初始化</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var p1 person</span><br><span class="line">    p1.name = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">    p1.age = 20</span><br><span class="line">    p1.sex = <span class="string">&quot;man&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用键值初始化"><a href="#使用键值初始化" class="headerlink" title="使用键值初始化"></a>使用键值初始化</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    p2 := person&#123; //注意每一行后面有逗号</span><br><span class="line">        name: <span class="string">&quot;lisi&quot;</span>,</span><br><span class="line">        age:  18,</span><br><span class="line">        sex:  <span class="string">&quot;woman&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//简写，初始化的时候不写键，注意:</span><br><span class="line">    // 必须初始化结构体的所有字段。</span><br><span class="line">    // 初始值的填充顺序必须与字段在结构体中的声明顺序一致。</span><br><span class="line">    // 该方式不能和键值初始化方式混用。</span><br><span class="line">    p3 := &amp;person&#123; //注意每一行后面有逗号</span><br><span class="line">        <span class="string">&quot;wangwu&quot;</span>,</span><br><span class="line">        18,</span><br><span class="line">        <span class="string">&quot;woman&quot;</span>,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    var user struct &#123;</span><br><span class="line">        name     string</span><br><span class="line">        password int</span><br><span class="line">    &#125;</span><br><span class="line">    user.name = <span class="string">&quot;plf&quot;</span></span><br><span class="line">    user.password = 123456</span><br><span class="line">    fmt.Println(user)</span><br></pre></td></tr></table></figure>

<h2 id="结构体字段的可见性"><a href="#结构体字段的可见性" class="headerlink" title="结构体字段的可见性"></a>结构体字段的可见性</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</span><br></pre></td></tr></table></figure>


<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func newPerson(name, city string, age int8) *person &#123;</span><br><span class="line">    <span class="built_in">return</span> &amp;person&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        city: city,</span><br><span class="line">        age:  age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//方法的定义格式如下:</span><br><span class="line">func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//例</span><br><span class="line">//Person 结构体</span><br><span class="line"><span class="built_in">type</span> Person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    age  int8</span><br><span class="line">&#125;</span><br><span class="line">//NewPerson 构造函数</span><br><span class="line">func NewPerson(name string, age int8) *Person &#123;</span><br><span class="line">    <span class="built_in">return</span> &amp;Person&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        age:  age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Dream Person做梦的方法</span><br><span class="line">func (p Person) <span class="function"><span class="title">Dream</span></span>() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s的梦想是学好Go语言！\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    p1 := NewPerson(<span class="string">&quot;plf&quot;</span>, 18)</span><br><span class="line">    p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="任意类型添加方法"><a href="#任意类型添加方法" class="headerlink" title="任意类型添加方法"></a>任意类型添加方法</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的int类型使用<span class="built_in">type</span>关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</span><br><span class="line">注意事项: 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h2 id="定义包"><a href="#定义包" class="headerlink" title="定义包"></a>定义包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package 包名</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="可见性-对外可见的成员注意要写注释"><a href="#可见性-对外可见的成员注意要写注释" class="headerlink" title="可见性 对外可见的成员注意要写注释"></a>可见性 对外可见的成员注意要写注释</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">如果想在一个包中引用另外一个包里的标识符（如变量、常量、类型、函数等）时，该标识符必须是对外可见的（public）。</span><br><span class="line">在Go语言中只需要将标识符的首字母大写就可以让标识符对外可见了。</span><br><span class="line">// 包变量可见性</span><br><span class="line">var a = 100 // 首字母小写，外部包不可见，只能在当前包内使用</span><br><span class="line">// 首字母大写外部包可见，可在其他包中使用</span><br><span class="line">const Mode = 1</span><br><span class="line"><span class="built_in">type</span> person struct &#123; // 首字母小写，外部包不可见，只能在当前包内使用</span><br><span class="line">    name string</span><br><span class="line">&#125;</span><br><span class="line">// Add 首字母大写，外部包可见，可在其他包中使用</span><br><span class="line">func Add(x, y int) int &#123;</span><br><span class="line">    <span class="built_in">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">age</span></span>() &#123; // 首字母小写，外部包不可见，只能在当前包内使用</span><br><span class="line">    var Age = 18 // 函数局部变量，外部包不可见，只能在当前函数内使用</span><br><span class="line">    fmt.Println(Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//结构体中的字段名和接口中的方法名如果首字母都是大写，外部包可以访问这些字段和方法</span><br><span class="line"><span class="built_in">type</span> Student struct &#123;</span><br><span class="line">    Name  string //可在包外访问的方法</span><br><span class="line">    class string //仅限包内访问的字段</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">type</span> Payer interface &#123;</span><br><span class="line">    init() //仅限包内访问的方法</span><br><span class="line">    Pay()  //可在包外访问的方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">要在代码中引用其他包的内容，需要使用import关键字导入使用的包。具体语法如下:</span><br><span class="line">import <span class="string">&quot;包的路径&quot;</span></span><br><span class="line">注意事项:</span><br><span class="line">import导入语句通常放在文件开头包声明语句的下面。</span><br><span class="line">导入的包名需要使用双引号包裹起来。</span><br><span class="line">包名是从<span class="variable">$GOPATH</span>/src/后开始计算的，使用/进行路径分隔。</span><br><span class="line">Go语言中禁止循环导入包。</span><br><span class="line"></span><br><span class="line">//单行导入</span><br><span class="line">单行导入的格式如下:</span><br><span class="line">import <span class="string">&quot;包1&quot;</span></span><br><span class="line">import <span class="string">&quot;包2&quot;</span></span><br><span class="line">//多行导入</span><br><span class="line">多行导入的格式如下:</span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;包1&quot;</span></span><br><span class="line">    <span class="string">&quot;包2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="自定义包名"><a href="#自定义包名" class="headerlink" title="自定义包名"></a>自定义包名</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在导入包名的时候，我们还可以为导入的包设置别名。通常用于导入的包名太长或者导入的包名冲突的情况。具体语法格式如下:</span><br><span class="line">import 别名 <span class="string">&quot;包的路径&quot;</span></span><br><span class="line">单行导入方式定义别名:</span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line">import m <span class="string">&quot;github.com/Q1mi/studygo/pkg_test&quot;</span></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    fmt.Println(m.Add(100, 200))</span><br><span class="line">    fmt.Println(m.Mode)</span><br><span class="line">&#125;</span><br><span class="line">多行导入方式定义别名:</span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    m <span class="string">&quot;github.com/Q1mi/studygo/pkg_test&quot;</span></span><br><span class="line"> )</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="匿名导入包"><a href="#匿名导入包" class="headerlink" title="匿名导入包"></a>匿名导入包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">如果只希望导入包，而不使用包内部的数据时，可以使用匿名导入包。具体的格式如下:</span><br><span class="line">import _ <span class="string">&quot;包的路径&quot;</span></span><br><span class="line">匿名导入的包与其他方式导入的包一样都会被编译到可执行文件中。</span><br></pre></td></tr></table></figure>

<h1 id="init-初始化函数"><a href="#init-初始化函数" class="headerlink" title="init()初始化函数"></a>init()初始化函数</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">init()函数介绍</span><br><span class="line">在Go语言程序执行时导入包语句会自动触发包内部init()函数的调用。</span><br><span class="line">需要注意的是: init()函数没有参数也没有返回值。</span><br><span class="line">init()函数在程序运行时自动被调用执行，不能在代码中主动调用它。</span><br><span class="line"></span><br><span class="line">init函数的执行时机:在全局声明之后，main函数之前</span><br><span class="line">全局声明-&gt; init函数 -&gt; main函数</span><br></pre></td></tr></table></figure>

<h1 id="init-函数执行顺序"><a href="#init-函数执行顺序" class="headerlink" title="init()函数执行顺序"></a>init()函数执行顺序</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Go语言包会从main包开始检查其导入的所有包，每个包中又可能导入了其他的包。Go编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。</span><br><span class="line">在运行时，被最后导入的包会最先初始化并调用其init()函数</span><br></pre></td></tr></table></figure>

<h1 id="重写init函数-相当于构造函数"><a href="#重写init函数-相当于构造函数" class="headerlink" title="重写init函数,相当于构造函数"></a>重写init函数,相当于构造函数</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">func <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;haha&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="接口是一种抽象的类型"><a href="#接口是一种抽象的类型" class="headerlink" title="接口是一种抽象的类型"></a>接口是一种抽象的类型</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在Go语言中接口（interface）是一种类型，一种抽象的类型。</span><br><span class="line">interface是一组method的集合，是duck-type programming的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）。</span><br><span class="line">为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型。</span><br></pre></td></tr></table></figure>


<h2 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">每个接口由数个方法组成，接口的定义格式如下:</span><br><span class="line"><span class="built_in">type</span> 接口类型名 interface&#123;</span><br><span class="line">    方法名1( 参数列表1 ) 返回值列表1</span><br><span class="line">    方法名2( 参数列表2 ) 返回值列表2</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line">接口名:使用<span class="built_in">type</span>将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义。</span><br><span class="line">方法名:当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</span><br><span class="line">参数列表、返回值列表:参数列表和返回值列表中的参数变量名可以省略。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line">//狗</span><br><span class="line"><span class="built_in">type</span> dog struct&#123;&#125;</span><br><span class="line">func (d dog) <span class="function"><span class="title">say</span></span>() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;www~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">//猫</span><br><span class="line"><span class="built_in">type</span> <span class="built_in">cat</span> struct&#123;&#125;</span><br><span class="line">func (c <span class="built_in">cat</span>) <span class="function"><span class="title">say</span></span>() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;mmm~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">//人</span><br><span class="line"><span class="built_in">type</span> person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">&#125;</span><br><span class="line">func (p person) <span class="function"><span class="title">say</span></span>() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;aaa~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">//接口，不管你是什么类型，只管你的方法</span><br><span class="line">//定义了一个抽象的类型， 只要你实现了say这个方法，都可以称为sayer这个类型</span><br><span class="line">//一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个需要实现的方法列表。</span><br><span class="line">//一个接口类型的变量可以存储所有实现了这个接口的变量</span><br><span class="line"><span class="built_in">type</span> sayer interface &#123;</span><br><span class="line">    say()</span><br><span class="line">&#125;</span><br><span class="line">//sayer代表方法，而不指定类型</span><br><span class="line">func hit(arg sayer) &#123;</span><br><span class="line">    arg.say() //不管传什么进来都执行say()方法</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    var d dog</span><br><span class="line">    hit(d)</span><br><span class="line">    var c <span class="built_in">cat</span></span><br><span class="line">    hit(c)</span><br><span class="line">    p := person&#123;</span><br><span class="line">        name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    hit(p)</span><br><span class="line">    var s sayer //接口类型的变量</span><br><span class="line">    s = p       //一个接口类型的变量可以存储所有实现了这个接口的变量</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">    s.say() //可以直接调用</span><br><span class="line">    hit(s)  //也可以作为形参传入</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="值接收者和指针接收者实现接口的区别"><a href="#值接收者和指针接收者实现接口的区别" class="headerlink" title="值接收者和指针接收者实现接口的区别"></a>值接收者和指针接收者实现接口的区别</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line">//定义了一个接口</span><br><span class="line"><span class="built_in">type</span> mover interface &#123;</span><br><span class="line">    move()</span><br><span class="line">&#125;</span><br><span class="line">//结构体</span><br><span class="line"><span class="built_in">type</span> person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    age  int</span><br><span class="line">&#125;</span><br><span class="line">//实现了接口里的所有方法，使用值类型接收</span><br><span class="line">//使用值类型接收时，m可以接收值类型与指针类型</span><br><span class="line">func (p person) <span class="function"><span class="title">move</span></span>() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s is moving\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line">//实现了接口里的所有方法，使用指针类型接收</span><br><span class="line">//使用指针类型接收时，m只能接收指针类型</span><br><span class="line">// func (p *person) <span class="function"><span class="title">move</span></span>() &#123;</span><br><span class="line">//  fmt.Printf(<span class="string">&quot;%s is moving\n&quot;</span>, p.name)</span><br><span class="line">// &#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    var m mover</span><br><span class="line">    p1 := person&#123;</span><br><span class="line">        name: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">        age:  20,</span><br><span class="line">    &#125;</span><br><span class="line">    p2 := &amp;person&#123;</span><br><span class="line">        name: <span class="string">&quot;lisi&quot;</span>,</span><br><span class="line">        age:  18,</span><br><span class="line">    &#125;</span><br><span class="line">    m = p1</span><br><span class="line">    m = p2</span><br><span class="line">    fmt.Println(m)</span><br><span class="line">    m.move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">接口与接口间可以通过嵌套创造出新的接口。</span><br><span class="line">// Sayer 接口</span><br><span class="line"><span class="built_in">type</span> Sayer interface &#123;</span><br><span class="line">    say()</span><br><span class="line">&#125;</span><br><span class="line">// Mover 接口</span><br><span class="line"><span class="built_in">type</span> Mover interface &#123;</span><br><span class="line">    move()</span><br><span class="line">&#125;</span><br><span class="line">// 接口嵌套</span><br><span class="line"><span class="built_in">type</span> animal interface &#123;</span><br><span class="line">    Sayer</span><br><span class="line">    Mover</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">空接口的定义</span><br><span class="line">空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。</span><br><span class="line">空接口类型的变量可以存储任意类型的变量。</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    // 定义一个空接口x</span><br><span class="line">    var x interface&#123;&#125;</span><br><span class="line">    s := <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    x = s</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">    i := 100</span><br><span class="line">    x = i</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">    b := <span class="literal">true</span></span><br><span class="line">    x = b</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="空接口的应用"><a href="#空接口的应用" class="headerlink" title="空接口的应用"></a>空接口的应用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">空接口作为函数的参数</span><br><span class="line">使用空接口实现可以接收任意类型的函数参数。</span><br><span class="line">// 空接口作为函数参数</span><br><span class="line">func show(a interface&#123;&#125;) &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, a, a)</span><br><span class="line">&#125;</span><br><span class="line">空接口作为map的值</span><br><span class="line">使用空接口实现可以保存任意类型值的字典。</span><br><span class="line">// 空接口作为map值</span><br><span class="line">    var studentInfo = make(map[string]interface&#123;&#125;)</span><br><span class="line">    studentInfo[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;张三&quot;</span></span><br><span class="line">    studentInfo[<span class="string">&quot;age&quot;</span>] = 18</span><br><span class="line">    studentInfo[<span class="string">&quot;married&quot;</span>] = <span class="literal">false</span></span><br><span class="line">    fmt.Println(studentInfo)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">想要判断空接口中的值这个时候就可以使用类型断言，其语法格式:</span><br><span class="line">x.(T)</span><br><span class="line">其中:</span><br><span class="line">x:表示类型为interface&#123;&#125;的变量</span><br><span class="line">T:表示断言x可能是的类型。</span><br><span class="line">该语法返回两个参数，第一个参数是x转化为T类型后的变量，第二个值是一个布尔值，若为<span class="literal">true</span>则表示断言成功，为<span class="literal">false</span>则表示断言失败。</span><br><span class="line">例:</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    var x interface&#123;&#125;</span><br><span class="line">    x = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    v, ok := x.(string)    //v储存值，ok判断x是否为string类型，是则ok返回<span class="literal">true</span>，否则<span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;类型断言失败&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="reflect包"><a href="#reflect包" class="headerlink" title="reflect包"></a>reflect包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在Go语言的反射机制中，任何接口值都由是一个具体类型和具体类型的值两部分组成的(我们在上一篇接口的博客中有介绍相关概念)。</span><br><span class="line">在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由reflect.Type和reflect.Value两部分组成，</span><br><span class="line">并且reflect包提供了reflect.TypeOf和reflect.ValueOf两个函数来获取任意对象的Value和Type。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="TypeOf"><a href="#TypeOf" class="headerlink" title="TypeOf"></a>TypeOf</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在Go语言中，使用reflect.TypeOf()函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。</span><br><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line">func reflectType(x interface&#123;&#125;) &#123;</span><br><span class="line">    v := reflect.TypeOf(x)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type:%v\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    var a float32 = 3.14</span><br><span class="line">    reflectType(a) // <span class="built_in">type</span>:float32</span><br><span class="line">    var b int64 = 100</span><br><span class="line">    reflectType(b) // <span class="built_in">type</span>:int64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="type-name和type-kind"><a href="#type-name和type-kind" class="headerlink" title="type name和type kind"></a>type name和type kind</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在反射中关于类型还划分为两种:类型（Type）和种类（Kind）。因为在Go语言中我们可以使用<span class="built_in">type</span>关键字构造很多自定义类型，而种类（Kind）就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到种类（Kind）。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。</span><br><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">type</span> myInt int64</span><br><span class="line">func reflectType(x interface&#123;&#125;) &#123;</span><br><span class="line">    t := reflect.TypeOf(x)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type:%v kind:%v\n&quot;</span>, t.Name(), t.Kind())</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    var a *float32 // 指针</span><br><span class="line">    var b myInt    // 自定义类型</span><br><span class="line">    var c rune     // 类型别名</span><br><span class="line">    reflectType(a) // <span class="built_in">type</span>: kind:ptr</span><br><span class="line">    reflectType(b) // <span class="built_in">type</span>:myInt kind:int64</span><br><span class="line">    reflectType(c) // <span class="built_in">type</span>:int32 kind:int32</span><br><span class="line">    <span class="built_in">type</span> person struct &#123;</span><br><span class="line">        name string</span><br><span class="line">        age  int</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">type</span> book struct&#123; title string &#125;</span><br><span class="line">    var d = person&#123;</span><br><span class="line">        name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">        age:  18,</span><br><span class="line">    &#125;</span><br><span class="line">    var e = book&#123;title: <span class="string">&quot;Go语言&quot;</span>&#125;</span><br><span class="line">    reflectType(d) // <span class="built_in">type</span>:person kind:struct</span><br><span class="line">    reflectType(e) // <span class="built_in">type</span>:book kind:struct</span><br><span class="line">&#125;</span><br><span class="line">Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的.Name()都是返回空。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ValueOf"><a href="#ValueOf" class="headerlink" title="ValueOf"></a>ValueOf</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reflect.ValueOf()返回的是reflect.Value类型，其中包含了原始值的值信息。reflect.Value与原始值之间可以互相转换。</span><br><span class="line">通过反射获取值</span><br><span class="line">func reflectValue(x interface&#123;&#125;) &#123;</span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    k := v.Kind()</span><br><span class="line">    switch k &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.Int64:</span><br><span class="line">        // v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type is int64, value is %d\n&quot;</span>, int64(v.Int()))</span><br><span class="line">    <span class="keyword">case</span> reflect.Float32:</span><br><span class="line">        // v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type is float32, value is %f\n&quot;</span>, float32(v.Float()))</span><br><span class="line">    <span class="keyword">case</span> reflect.Float64:</span><br><span class="line">        // v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type is float64, value is %f\n&quot;</span>, float64(v.Float()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    var a float32 = 3.14</span><br><span class="line">    var b int64 = 100</span><br><span class="line">    reflectValue(a) // <span class="built_in">type</span> is float32, value is 3.140000</span><br><span class="line">    reflectValue(b) // <span class="built_in">type</span> is int64, value is 100</span><br><span class="line">    // 将int类型的原始值转换为reflect.Value类型</span><br><span class="line">    c := reflect.ValueOf(10)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type c :%T\n&quot;</span>, c) // <span class="built_in">type</span> c :reflect.Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过反射设置变量的值"><a href="#通过反射设置变量的值" class="headerlink" title="通过反射设置变量的值"></a>通过反射设置变量的值</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的Elem()方法来获取指针对应的值。</span><br><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line">func reflectSetValue1(x interface&#123;&#125;) &#123;</span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    <span class="keyword">if</span> v.Kind() == reflect.Int64 &#123;</span><br><span class="line">        v.SetInt(200) //修改的是副本，reflect包会引发panic</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func reflectSetValue2(x interface&#123;&#125;) &#123;</span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    // 反射中使用 Elem()方法获取指针对应的值</span><br><span class="line">    <span class="keyword">if</span> v.Elem().Kind() == reflect.Int64 &#123;</span><br><span class="line">        v.Elem().SetInt(200)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    var a int64 = 100</span><br><span class="line">    // reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value</span><br><span class="line">    reflectSetValue2(&amp;a)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line">isNil()和isValid()</span><br><span class="line">IsNil()常被用于判断指针是否为空；IsValid()常被用于判定返回值是否有效。</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    // *int类型空指针</span><br><span class="line">    var a *int</span><br><span class="line">    fmt.Println(<span class="string">&quot;var a *int IsNil:&quot;</span>, reflect.ValueOf(a).IsNil())</span><br><span class="line">    // nil值</span><br><span class="line">    fmt.Println(<span class="string">&quot;nil IsValid:&quot;</span>, reflect.ValueOf(nil).IsValid())</span><br><span class="line">    // 实例化一个匿名结构体</span><br><span class="line">    b := struct&#123;&#125;&#123;&#125;</span><br><span class="line">    // 尝试从结构体中查找<span class="string">&quot;abc&quot;</span>字段</span><br><span class="line">    fmt.Println(<span class="string">&quot;不存在的结构体成员:&quot;</span>, reflect.ValueOf(b).FieldByName(<span class="string">&quot;abc&quot;</span>).IsValid())</span><br><span class="line">    // 尝试从结构体中查找<span class="string">&quot;abc&quot;</span>方法</span><br><span class="line">    fmt.Println(<span class="string">&quot;不存在的结构体方法:&quot;</span>, reflect.ValueOf(b).MethodByName(<span class="string">&quot;abc&quot;</span>).IsValid())</span><br><span class="line">    // map</span><br><span class="line">    c := map[string]int&#123;&#125;</span><br><span class="line">    // 尝试从map中查找一个不存在的键</span><br><span class="line">    fmt.Println(<span class="string">&quot;map中不存在的键:&quot;</span>, reflect.ValueOf(c).MapIndex(reflect.ValueOf(<span class="string">&quot;娜扎&quot;</span>)).IsValid())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="结构体反射"><a href="#结构体反射" class="headerlink" title="结构体反射"></a>结构体反射</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">StructField类型</span><br><span class="line">StructField类型用来描述结构体中的一个字段的信息。</span><br><span class="line">结构体反射示例</span><br><span class="line">当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。</span><br><span class="line"><span class="built_in">type</span> student struct &#123;</span><br><span class="line">    Name  string `json:<span class="string">&quot;name&quot;</span>`</span><br><span class="line">    Score int    `json:<span class="string">&quot;score&quot;</span>`</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    stu1 := student&#123;</span><br><span class="line">        Name:  <span class="string">&quot;zhansan&quot;</span>,</span><br><span class="line">        Score: 90,</span><br><span class="line">    &#125;</span><br><span class="line">    t := reflect.TypeOf(stu1)</span><br><span class="line">    fmt.Println(t.Name(), t.Kind()) // student struct</span><br><span class="line">    // 通过<span class="keyword">for</span>循环遍历结构体的所有字段信息</span><br><span class="line">    <span class="keyword">for</span> i := 0; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">        field := t.Field(i)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, field.Name, field.Index, field.Type, field.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    // 通过字段名获取指定结构体字段信息</span><br><span class="line">    <span class="keyword">if</span> scoreField, ok := t.FieldByName(<span class="string">&quot;Score&quot;</span>); ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="编写函数printMethod-s-interface-来遍历打印s包含的方法。"><a href="#编写函数printMethod-s-interface-来遍历打印s包含的方法。" class="headerlink" title="编写函数printMethod(s interface{})来遍历打印s包含的方法。"></a>编写函数printMethod(s interface{})来遍历打印s包含的方法。</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 给student添加两个方法 Study和Sleep(注意首字母大写)</span><br><span class="line">func (s student) Study() string &#123;</span><br><span class="line">    msg := <span class="string">&quot;好好学习，天天向上。&quot;</span></span><br><span class="line">    fmt.Println(msg)</span><br><span class="line">    <span class="built_in">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line">func (s student) Sleep() string &#123;</span><br><span class="line">    msg := <span class="string">&quot;好好睡觉，快快长大。&quot;</span></span><br><span class="line">    fmt.Println(msg)</span><br><span class="line">    <span class="built_in">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line">func printMethod(x interface&#123;&#125;) &#123;</span><br><span class="line">    t := reflect.TypeOf(x)</span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    fmt.Println(t.NumMethod())</span><br><span class="line">    <span class="keyword">for</span> i := 0; i &lt; v.NumMethod(); i++ &#123;</span><br><span class="line">        methodType := v.Method(i).Type()</span><br><span class="line">        fmt.Printf(<span class="string">&quot;method name:%s\n&quot;</span>, t.Method(i).Name)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;method:%s\n&quot;</span>, methodType)</span><br><span class="line">        // 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span><br><span class="line">        var args = []reflect.Value&#123;&#125;</span><br><span class="line">        v.Method(i).Call(args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line">func <span class="function"><span class="title">hello</span></span>() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    wg.Done() //通知计数器减1</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123; //开启一个主goroutine去执行main函数</span><br><span class="line">    wg.Add(1)  //计数器加1</span><br><span class="line">    go hello() //另开启一个goroutine去执行hello函数</span><br><span class="line">    fmt.Println(<span class="string">&quot;nihao&quot;</span>)</span><br><span class="line">    // time.Sleep(time.Second) //等待1秒</span><br><span class="line">    wg.Wait() //阻塞住， 直到计数器变为0， 才退出</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</span><br><span class="line">Go语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。</span><br><span class="line">Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</span><br><span class="line">我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子:</span><br><span class="line">func <span class="function"><span class="title">a</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> i := 1; i &lt; 10; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;A:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">b</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> i := 1; i &lt; 10; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;B:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    runtime.GOMAXPROCS(1)  //指定为1个核心</span><br><span class="line">    go a()</span><br><span class="line">    go b()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="channel类型"><a href="#channel类型" class="headerlink" title="channel类型"></a>channel类型</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">channel是一种类型，一种引用类型。声明通道类型的格式如下:</span><br><span class="line">var 变量 chan 元素类型</span><br><span class="line">举几个例子:</span><br><span class="line">var ch1 chan int   // 声明一个传递整型的通道</span><br><span class="line">var ch2 chan bool  // 声明一个传递布尔型的通道</span><br><span class="line">var ch3 chan []int // 声明一个传递int切片的通道</span><br></pre></td></tr></table></figure>

<h2 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">通道是引用类型，通道类型的空值是nil。</span><br><span class="line">var ch chan int</span><br><span class="line">fmt.Println(ch) // &lt;nil&gt;</span><br><span class="line">声明的通道后需要使用make函数初始化之后才能使用。</span><br><span class="line">创建channel的格式如下:</span><br><span class="line">make(chan 元素类型, [缓冲大小])</span><br><span class="line">channel的缓冲大小是可选的。</span><br><span class="line">举几个例子:</span><br><span class="line">ch4 := make(chan int)</span><br><span class="line">ch5 := make(chan bool)</span><br><span class="line">ch6 := make(chan []int)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">通道有发送（send）、接收(receive）和关闭（close）三种操作。</span><br><span class="line">发送和接收都使用&lt;-符号。</span><br><span class="line">现在我们先使用以下语句定义一个通道:</span><br><span class="line">ch := make(chan int)</span><br></pre></td></tr></table></figure>

<h2 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">将一个值发送到通道中。</span><br><span class="line">ch &lt;- 10 // 把10发送到ch中</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">从一个通道中接收值。</span><br><span class="line">x := &lt;- ch // 从ch中接收值并赋值给变量x</span><br><span class="line">&lt;-ch       // 从ch中接收值，忽略结果</span><br></pre></td></tr></table></figure>

<h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">我们通过调用内置的close函数来关闭通道。</span><br><span class="line">close(ch)</span><br><span class="line">关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</span><br><span class="line">关闭后的通道有以下特点:</span><br><span class="line">对一个关闭的通道再发送值就会导致panic。</span><br><span class="line">对一个关闭的通道进行接收会一直获取值直到通道为空。</span><br><span class="line">对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</span><br><span class="line">关闭一个已经关闭的通道会导致panic。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a>无缓冲的通道</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码:</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    ch := make(chan int)</span><br><span class="line">    ch &lt;- 10</span><br><span class="line">    fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">上面这段代码能够通过编译，但是执行的时候会出现以下错误:</span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line">goroutine 1 [chan send]:</span><br><span class="line">main.main()</span><br><span class="line">        .../src/github.com/Q1mi/studygo/day06/channel02/main.go:8 +0x54</span><br><span class="line">为什么会出现deadlock错误呢？</span><br><span class="line">因为我们使用ch := make(chan int)创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。</span><br><span class="line">上面的代码会阻塞在ch &lt;- 10这一行代码形成死锁，那如何解决这个问题呢？</span><br><span class="line">一种方法是启用一个goroutine去接收值，例如:</span><br><span class="line">func recv(c chan int) &#123;</span><br><span class="line">    ret := &lt;-c</span><br><span class="line">    fmt.Println(<span class="string">&quot;接收成功&quot;</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    ch := make(chan int)</span><br><span class="line">    go recv(ch) // 启用goroutine从通道接收值</span><br><span class="line">    ch &lt;- 10</span><br><span class="line">    fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。</span><br><span class="line">使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a>有缓冲的通道</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如:</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    ch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道</span><br><span class="line">    ch &lt;- 10</span><br><span class="line">    fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</span><br><span class="line">我们可以使用内置的len函数获取通道内元素的数量，使用<span class="built_in">cap</span>函数获取通道的容量，虽然我们很少会这么做。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="for-range从通道循环取值"><a href="#for-range从通道循环取值" class="headerlink" title="for range从通道循环取值"></a>for range从通道循环取值</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">当向通道中发送完数据时，我们可以通过close函数来关闭通道。</span><br><span class="line">当通道被关闭时，再往该通道发送值会引发panic，从该通道取值的操作会先取完通道中的值，再然后取到的值一直都是对应类型的零值。那如何判断一个通道是否被关闭了呢？</span><br><span class="line">我们来看下面这个例子:</span><br><span class="line">// channel 练习</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    ch1 := make(chan int)</span><br><span class="line">    ch2 := make(chan int)</span><br><span class="line">    // 开启goroutine将0~100的数发送到ch1中</span><br><span class="line">    go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">            ch1 &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        close(ch1)</span><br><span class="line">    &#125;()</span><br><span class="line">    // 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中</span><br><span class="line">    go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            i, ok := &lt;-ch1 // 通道关闭后再取值ok=<span class="literal">false</span></span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="built_in">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            ch2 &lt;- i * i</span><br><span class="line">        &#125;</span><br><span class="line">        close(ch2)</span><br><span class="line">    &#125;()</span><br><span class="line">    // 在主goroutine中从ch2中接收值打印</span><br><span class="line">    <span class="keyword">for</span> i := range ch2 &#123; // 通道关闭后会退出<span class="keyword">for</span> range循环</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过我们通常使用的是<span class="keyword">for</span> range的方式。</span><br><span class="line">使用<span class="keyword">for</span> range遍历通道，当通道被关闭的时候就会退出<span class="keyword">for</span> range。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</span><br><span class="line">Go语言中提供了单向通道来处理这种情况。例如，我们把上面的例子改造如下:</span><br><span class="line">func counter(out chan&lt;- int) &#123;</span><br><span class="line">    <span class="keyword">for</span> i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">        out &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    close(out)</span><br><span class="line">&#125;</span><br><span class="line">func squarer(out chan&lt;- int, <span class="keyword">in</span> &lt;-chan int) &#123;</span><br><span class="line">    <span class="keyword">for</span> i := range <span class="keyword">in</span> &#123;</span><br><span class="line">        out &lt;- i * i</span><br><span class="line">    &#125;</span><br><span class="line">    close(out)</span><br><span class="line">&#125;</span><br><span class="line">func printer(<span class="keyword">in</span> &lt;-chan int) &#123;</span><br><span class="line">    <span class="keyword">for</span> i := range <span class="keyword">in</span> &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    ch1 := make(chan int)</span><br><span class="line">    ch2 := make(chan int)</span><br><span class="line">    go counter(ch1)</span><br><span class="line">    go squarer(ch2, ch1)</span><br><span class="line">    printer(ch2)</span><br><span class="line">&#125;</span><br><span class="line">其中，</span><br><span class="line">chan&lt;- int是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作；</span><br><span class="line">&lt;-chan int是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。</span><br><span class="line">在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="worker-pool（goroutine池）"><a href="#worker-pool（goroutine池）" class="headerlink" title="worker pool（goroutine池）"></a>worker pool（goroutine池）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在工作中我们通常会使用可以指定启动的goroutine数量–worker pool模式，控制goroutine的数量，防止goroutine泄漏和暴涨。</span><br><span class="line">一个简易的work pool示例代码如下:</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line">func worker(<span class="built_in">id</span> int, <span class="built_in">jobs</span> &lt;-chan int, results chan&lt;- int) &#123;</span><br><span class="line">    <span class="keyword">for</span> j := range <span class="built_in">jobs</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;worker:%d start job:%d\n&quot;</span>, <span class="built_in">id</span>, j)</span><br><span class="line">        time.Sleep(time.Millisecond * 500)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;worker:%d end job:%d\n&quot;</span>, <span class="built_in">id</span>, j)</span><br><span class="line">        results &lt;- j * 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">jobs</span> := make(chan int, 100)</span><br><span class="line">    results := make(chan int, 100)</span><br><span class="line">    // 开启3个goroutine</span><br><span class="line">    <span class="keyword">for</span> w := 1; w &lt;= 3; w++ &#123;</span><br><span class="line">        go worker(w, <span class="built_in">jobs</span>, results)</span><br><span class="line">    &#125;</span><br><span class="line">    // 5个任务</span><br><span class="line">    <span class="keyword">for</span> j := 1; j &lt;= 5; j++ &#123;</span><br><span class="line">        <span class="built_in">jobs</span> &lt;- j</span><br><span class="line">    &#125;</span><br><span class="line">    close(<span class="built_in">jobs</span>)</span><br><span class="line">    // 输出结果</span><br><span class="line">    <span class="keyword">for</span> a := 1; a &lt;= 5; a++ &#123;</span><br><span class="line">        &lt;-results</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">select的使用类似于switch语句，它有一系列<span class="keyword">case</span>分支和一个默认的分支。每个<span class="keyword">case</span>会对应一个通道的通信（接收或发送）过程。select会一直等待，直到某个<span class="keyword">case</span>的通信操作完成时，就会执行<span class="keyword">case</span>分支对应的s语句。具体格式如下:</span><br><span class="line">select&#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> data := &lt;-ch2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> ch3&lt;-data:</span><br><span class="line">        ...</span><br><span class="line">    default:</span><br><span class="line">        默认操作</span><br><span class="line">&#125;</span><br><span class="line">举个小例子来演示下select的使用:</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    ch := make(chan int, 1)</span><br><span class="line">    <span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        <span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">            fmt.Println(x)</span><br><span class="line">        <span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">使用select语句能提高代码的可读性。</span><br><span class="line">可处理一个或多个channel的发送/接收操作。</span><br><span class="line">如果多个<span class="keyword">case</span>同时满足，select会随机选择一个。</span><br><span class="line">对于没有<span class="keyword">case</span>的select&#123;&#125;会一直等待，可用于阻塞main函数。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="并发安全和锁"><a href="#并发安全和锁" class="headerlink" title="并发安全和锁"></a>并发安全和锁</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">有时候在Go代码中可能会存在多个goroutine同时操作一个资源（临界区），这种情况会发生竞态问题（数据竞态）。</span><br><span class="line">类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。</span><br><span class="line">Go语言中使用<span class="built_in">sync</span>包的Mutex类型来实现互斥锁。</span><br><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line">var (</span><br><span class="line">    x    int64</span><br><span class="line">    wg   sync.WaitGroup</span><br><span class="line">    lock sync.Mutex //互斥锁</span><br><span class="line">)</span><br><span class="line">func <span class="function"><span class="title">add</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> i := 0; i &lt; 5000; i++ &#123;</span><br><span class="line">        lock.Lock() //上锁</span><br><span class="line">        x++</span><br><span class="line">        lock.Unlock() //解锁</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    wg.Add(2)</span><br><span class="line">    go add()</span><br><span class="line">    go add()</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用<span class="built_in">sync</span>包中的RWMutex类型。</span><br><span class="line">读写锁分为两种:读锁和写锁。当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line">var (</span><br><span class="line">    x      int64</span><br><span class="line">    wg     sync.WaitGroup</span><br><span class="line">    lock   sync.Mutex   //用互斥锁用时1.88s</span><br><span class="line">    rwlock sync.RWMutex //用读写锁用时111ms</span><br><span class="line">)</span><br><span class="line">func <span class="function"><span class="title">read</span></span>() &#123;</span><br><span class="line">    // lock.Lock()</span><br><span class="line">    rwlock.RLock()</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">    // lock.Unlock()</span><br><span class="line">    rwlock.RUnlock()</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">write</span></span>() &#123;</span><br><span class="line">    // lock.Lock()</span><br><span class="line">    rwlock.Lock()</span><br><span class="line">    x++</span><br><span class="line">    time.Sleep(time.Millisecond * 10)</span><br><span class="line">    // lock.Unlock()</span><br><span class="line">    rwlock.Unlock()</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    <span class="keyword">for</span> i := 0; i &lt; 1000; i++ &#123;</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go <span class="built_in">read</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go write()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(time.Now().Sub(start))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。</span><br><span class="line">Go语言中的<span class="built_in">sync</span>包中提供了一个针对只执行一次场景的解决方案–sync.Once。</span><br><span class="line">sync.Once只有一个Do方法，其签名如下:</span><br><span class="line">func (o *Once) Do(f func()) &#123;&#125;</span><br><span class="line">备注:如果要执行的函数f需要传递参数就需要搭配闭包来使用。</span><br><span class="line">加载配置文件示例</span><br><span class="line">var icons map[string]image.Image</span><br><span class="line">var loadIconsOnce sync.Once</span><br><span class="line">func <span class="function"><span class="title">loadIcons</span></span>() &#123;</span><br><span class="line">    icons = map[string]image.Image&#123;</span><br><span class="line">        <span class="string">&quot;left&quot;</span>:  loadIcon(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;up&quot;</span>:    loadIcon(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;right&quot;</span>: loadIcon(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;down&quot;</span>:  loadIcon(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Icon 是并发安全的</span><br><span class="line">func Icon(name string) image.Image &#123;</span><br><span class="line">    loadIconsOnce.Do(loadIcons)</span><br><span class="line">    <span class="built_in">return</span> icons[name]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Go语言的<span class="built_in">sync</span>包中提供了一个开箱即用的并发安全版map–sync.Map。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法。</span><br><span class="line">var m = sync.Map&#123;&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := 0; i &lt; 20; i++ &#123;</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go func(n int) &#123;</span><br><span class="line">            key := strconv.Itoa(n)</span><br><span class="line">            m.Store(key, n)</span><br><span class="line">            value, _ := m.Load(key)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">原子操作:使用内置的函数对数据进行操作</span><br><span class="line"></span><br><span class="line">代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库<span class="built_in">sync</span>/atomic提供。</span><br><span class="line">atomic包</span><br><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line">//Counter interface</span><br><span class="line"><span class="built_in">type</span> Counter interface &#123;</span><br><span class="line">    Inc()</span><br><span class="line">    Load() int64</span><br><span class="line">&#125;</span><br><span class="line">// CommonCounter 普通版</span><br><span class="line"><span class="built_in">type</span> CommonCounter struct &#123;</span><br><span class="line">    counter int64</span><br><span class="line">&#125;</span><br><span class="line">//Inc inc</span><br><span class="line">func (c CommonCounter) <span class="function"><span class="title">Inc</span></span>() &#123;</span><br><span class="line">    c.counter++</span><br><span class="line">&#125;</span><br><span class="line">//Load load</span><br><span class="line">func (c CommonCounter) Load() int64 &#123;</span><br><span class="line">    <span class="built_in">return</span> c.counter</span><br><span class="line">&#125;</span><br><span class="line">//MutexCounter 互斥锁版</span><br><span class="line"><span class="built_in">type</span> MutexCounter struct &#123;</span><br><span class="line">    counter int64</span><br><span class="line">    lock    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line">//Inc inc</span><br><span class="line">func (m *MutexCounter) <span class="function"><span class="title">Inc</span></span>() &#123;</span><br><span class="line">    m.lock.Lock()</span><br><span class="line">    defer m.lock.Unlock()</span><br><span class="line">    m.counter++</span><br><span class="line">&#125;</span><br><span class="line">//Load load</span><br><span class="line">func (m *MutexCounter) Load() int64 &#123;</span><br><span class="line">    m.lock.Lock()</span><br><span class="line">    defer m.lock.Unlock()</span><br><span class="line">    <span class="built_in">return</span> m.counter</span><br><span class="line">&#125;</span><br><span class="line">//AtomicCounter 原子操作版</span><br><span class="line"><span class="built_in">type</span> AtomicCounter struct &#123;</span><br><span class="line">    counter int64</span><br><span class="line">&#125;</span><br><span class="line">//Inc inc</span><br><span class="line">func (a *AtomicCounter) <span class="function"><span class="title">Inc</span></span>() &#123;</span><br><span class="line">    atomic.AddInt64(&amp;a.counter, 1)</span><br><span class="line">&#125;</span><br><span class="line">//Load load</span><br><span class="line">func (a *AtomicCounter) Load() int64 &#123;</span><br><span class="line">    <span class="built_in">return</span> atomic.LoadInt64(&amp;a.counter)</span><br><span class="line">&#125;</span><br><span class="line">func <span class="built_in">test</span>(c Counter) &#123;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    start := time.Now()</span><br><span class="line">    <span class="keyword">for</span> i := 0; i &lt; 1000; i++ &#123;</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">            c.Inc()</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    end := time.Now()</span><br><span class="line">    fmt.Println(c.Load(), end.Sub(start))</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    c1 := CommonCounter&#123;&#125; // 非并发安全</span><br><span class="line">    <span class="built_in">test</span>(c1)</span><br><span class="line">    c2 := MutexCounter&#123;&#125; // 使用互斥锁实现并发安全</span><br><span class="line">    <span class="built_in">test</span>(&amp;c2)</span><br><span class="line">    c3 := AtomicCounter&#123;&#125; // 并发安全且比互斥锁效率更高</span><br><span class="line">    <span class="built_in">test</span>(&amp;c3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h1><h2 id="TCP服务端"><a href="#TCP服务端" class="headerlink" title="TCP服务端"></a>TCP服务端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line">// TCP server端</span><br><span class="line">// 处理函数</span><br><span class="line">func process(conn net.Conn) &#123;</span><br><span class="line">    defer conn.Close() // 处理完之后关闭连接</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        reader := bufio.NewReader(conn)</span><br><span class="line">        var buf [128]byte             //定义数组</span><br><span class="line">        n, err := reader.Read(buf[:]) // 读取数据， 数组转成了切片</span><br><span class="line">        <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;read from client failed, err:&quot;</span>, err)</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        recvStr := string(buf[:n])</span><br><span class="line">        <span class="keyword">if</span> recvStr == <span class="string">&quot;exit&quot;</span> &#123;</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;收到client端发来的数据:&quot;</span>, recvStr) //打印接收到的数组</span><br><span class="line">        conn.Write([]byte(recvStr))             // 发送数据， 把数据发回给客户端</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:20000&quot;</span>) //启动监听， 并指定类型与端口</span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;listen failed, err:&quot;</span>, err)</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123; //一直监听</span><br><span class="line">        conn, err := listen.Accept() // 建立连接。一直阻塞，直到有人连接</span><br><span class="line">        <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;accept failed, err:&quot;</span>, err)</span><br><span class="line">            <span class="built_in">continue</span> //如果连接出错， 就跳过后面的启动goroutine， 进行下一次等待连接</span><br><span class="line">        &#125;</span><br><span class="line">        go process(conn) // 启动一个goroutine处理连接</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line">// tcp客户端</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:20000&quot;</span>) //建立连接， Dial（拨号）</span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;err :&quot;</span>, err)</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    defer conn.Close() // 关闭连接</span><br><span class="line">    inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Print(<span class="string">&quot;发送:&quot;</span>)</span><br><span class="line">        input, _ := inputReader.ReadString(<span class="string">&#x27;\n&#x27;</span>)  // 读取用户输入</span><br><span class="line">        inputInfo := strings.Trim(input, <span class="string">&quot;\r\n&quot;</span>)  //去掉指定字符</span><br><span class="line">        <span class="keyword">if</span> strings.ToUpper(inputInfo) == <span class="string">&quot;exit&quot;</span> &#123; // 如果输入<span class="built_in">exit</span>就退出</span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        _, err = conn.Write([]byte(inputInfo)) // 发送数据</span><br><span class="line">        <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        //从服务器接收返回的消息</span><br><span class="line">        buf := [512]byte&#123;&#125;</span><br><span class="line">        n, err := conn.Read(buf[:])</span><br><span class="line">        <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;recv failed, err:&quot;</span>, err)</span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;受到服务器回复:接收&quot;</span>, string(buf[:n]), <span class="string">&quot;成功&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h1><h2 id="UDP服务端"><a href="#UDP服务端" class="headerlink" title="UDP服务端"></a>UDP服务端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line">// UDP server端</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    listen, err := net.ListenUDP(<span class="string">&quot;udp&quot;</span>, &amp;net.UDPAddr&#123; //启动监听， 并设置地址</span><br><span class="line">        IP:   net.IPv4(0, 0, 0, 0),</span><br><span class="line">        Port: 30000,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;listen failed, err:&quot;</span>, err)</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    defer listen.Close()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        var data [1024]byte</span><br><span class="line">        n, addr, err := listen.ReadFromUDP(data[:]) // 接收数据</span><br><span class="line">        <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;read udp failed, err:&quot;</span>, err)</span><br><span class="line">            <span class="built_in">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;data:%v addr:%v count:%v\n&quot;</span>, string(data[:n]), addr, n)</span><br><span class="line">        _, err = listen.WriteToUDP(data[:n], addr) // 发送数据</span><br><span class="line">        <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;write to udp failed, err:&quot;</span>, err)</span><br><span class="line">            <span class="built_in">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="UDP客户端"><a href="#UDP客户端" class="headerlink" title="UDP客户端"></a>UDP客户端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line">// UDP server端</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    listen, err := net.ListenUDP(<span class="string">&quot;udp&quot;</span>, &amp;net.UDPAddr&#123; //启动监听， 并设置地址</span><br><span class="line">        IP:   net.IPv4(0, 0, 0, 0),</span><br><span class="line">        Port: 30000,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;listen failed, err:&quot;</span>, err)</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    defer listen.Close()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        var data [1024]byte</span><br><span class="line">        n, addr, err := listen.ReadFromUDP(data[:]) // 接收数据</span><br><span class="line">        <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;read udp failed, err:&quot;</span>, err)</span><br><span class="line">            <span class="built_in">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;data:%v addr:%v count:%v\n&quot;</span>, string(data[:n]), addr, n)</span><br><span class="line">        _, err = listen.WriteToUDP(data[:n], addr) // 发送数据</span><br><span class="line">        <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;write to udp failed, err:&quot;</span>, err)</span><br><span class="line">            <span class="built_in">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">秋山澪</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/golang-note/">http://example.com/golang-note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">木风可可</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/Golang/">Golang</a></div><div class="post_share"><div class="social-share" data-image="http://yanxuan.nosdn.127.net/8f4f53c328ba7a1e1b8d98fb0129463a.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="http://yanxuan.nosdn.127.net/300a62f2490c6f17d511841dcae1f924.jpg" target="_blank"><img class="post-qr-code-img" src="http://yanxuan.nosdn.127.net/300a62f2490c6f17d511841dcae1f924.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="http://yanxuan.nosdn.127.net/05d2ee6a16f637910d76d76eb1c3eca1.jpg" target="_blank"><img class="post-qr-code-img" src="http://yanxuan.nosdn.127.net/05d2ee6a16f637910d76d76eb1c3eca1.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/ros-note/"><img class="prev-cover" src="http://yanxuan.nosdn.127.net/576bd3ecf4ccd416258840e84ed61122.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ROS学习</div></div></a></div><div class="next-post pull-right"><a href="/java-note/"><img class="next-cover" src="http://yanxuan.nosdn.127.net/572d0b7effb57de19953498632b99783.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/autocad-note/" title="AutoCAD学习"><img class="cover" src="https://s1.ax1x.com/2020/11/10/BL2zDJ.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-03</div><div class="title">AutoCAD学习</div></div></a></div><div><a href="/ad-note/" title="AltiumDesigner学习"><img class="cover" src="http://yanxuan.nosdn.127.net/986042e56f5523fc4bff794e4b6c4586.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-30</div><div class="title">AltiumDesigner学习</div></div></a></div><div><a href="/c++note/" title="C++学习"><img class="cover" src="http://yanxuan.nosdn.127.net/27ad4240afb3fa07197eaec257022c89.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-03</div><div class="title">C++学习</div></div></a></div><div><a href="/git-used/" title="GIT使用笔记"><img class="cover" src="https://s1.ax1x.com/2020/07/19/UWJuZR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-19</div><div class="title">GIT使用笔记</div></div></a></div><div><a href="/linux-note/" title="Linux学习"><img class="cover" src="http://yanxuan.nosdn.127.net/77fafe855fffa4e29aa30b56af8af642.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-03</div><div class="title">Linux学习</div></div></a></div><div><a href="/Qt-note/" title="Qt学习笔记"><img class="cover" src="https://s1.ax1x.com/2020/07/19/UWJDW8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-19</div><div class="title">Qt学习笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s1.ax1x.com/2020/10/17/0LTXFK.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">秋山澪</div><div class="author-info__description">木风可可的博客</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sorrowfeng"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">木风可可的个人小站</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#go%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%B8%8D%E7%94%A8%E5%86%99%E5%88%86%E5%8F%B7"><span class="toc-number">1.</span> <span class="toc-text">go语言中不用写分号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hello-World"><span class="toc-number">2.</span> <span class="toc-text">Hello World</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">3.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91"><span class="toc-number">4.</span> <span class="toc-text">跨平台编译</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%EF%BC%8Cgo%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8F%98%E9%87%8F%E5%BF%85%E9%A1%BB%E5%85%88%E5%A3%B0%E6%98%8E%E5%86%8D%E4%BD%BF%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">变量声明，go语言中变量必须先声明再使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">6.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#iota-ota%E6%98%AFgo%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B8%B8%E9%87%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%8C%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%B8%B8%E9%87%8F%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%E3%80%82"><span class="toc-number">7.</span> <span class="toc-text">iota:ota是go语言的常量计数器，只能在常量的表达式中使用。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">9.</span> <span class="toc-text">浮点型:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bool%E5%9E%8B"><span class="toc-number">10.</span> <span class="toc-text">bool型:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="toc-number">11.</span> <span class="toc-text">字符串操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E7%AC%A6"><span class="toc-number">12.</span> <span class="toc-text">转义符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">13.</span> <span class="toc-text">多行字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#strings%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">14.</span> <span class="toc-text">strings常用函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#byte%E5%92%8Crune%E7%B1%BB%E5%9E%8B"><span class="toc-number">15.</span> <span class="toc-text">byte和rune类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">16.</span> <span class="toc-text">遍历字符串两种方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">17.</span> <span class="toc-text">修改字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">18.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">19.</span> <span class="toc-text">算数运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%87%E7%89%87"><span class="toc-number">20.</span> <span class="toc-text">切片</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">20.1.</span> <span class="toc-text">切片的定义和初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8make-%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E5%88%87%E7%89%87"><span class="toc-number">20.2.</span> <span class="toc-text">使用make()函数构造切片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8append-%E5%87%BD%E6%95%B0%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">20.3.</span> <span class="toc-text">使用append()函数添加元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8copy%E5%87%BD%E6%95%B0%E8%B5%8B%E5%80%BC%E5%88%87%E7%89%87%EF%BC%8C%E9%81%BF%E5%85%8D%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E5%85%B1%E7%94%A8%E4%B8%80%E5%9D%97%E5%86%85%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">20.4.</span> <span class="toc-text">使用copy函数赋值切片，避免直接赋值共用一块内存的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E7%89%87%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%8C%E5%88%A9%E7%94%A8append%E5%87%BD%E6%95%B0"><span class="toc-number">20.5.</span> <span class="toc-text">切片删除元素，利用append函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%88%87%E7%89%87%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="toc-number">20.6.</span> <span class="toc-text">判断切片是否为空</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E7%89%87%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E6%AF%94%E8%BE%83"><span class="toc-number">20.7.</span> <span class="toc-text">切片不能直接比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#map"><span class="toc-number">21.</span> <span class="toc-text">map</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#map%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">21.1.</span> <span class="toc-text">map的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8for-range%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E9%81%8D%E5%8E%86map"><span class="toc-number">21.2.</span> <span class="toc-text">用for range的遍历方法遍历map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E9%94%AE%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-number">21.3.</span> <span class="toc-text">判断某个键是否存在</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8delete%E5%88%A0%E9%99%A4%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-number">21.4.</span> <span class="toc-text">使用delete删除键值对</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%A3%B0%E6%98%8E%E7%9A%84%E5%90%8C%E6%97%B6%E5%A1%AB%E5%85%85%E5%85%83%E7%B4%A0"><span class="toc-number">21.5.</span> <span class="toc-text">在声明的同时填充元素</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">22.</span> <span class="toc-text">随机数的使用方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">23.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#defer"><span class="toc-number">24.</span> <span class="toc-text">defer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">25.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%AE%9E%E4%BE%8B"><span class="toc-number">26.</span> <span class="toc-text">闭包实例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#panir-x2F-recover%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">27.</span> <span class="toc-text">panir&#x2F;recover异常处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">28.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#new%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98"><span class="toc-number">29.</span> <span class="toc-text">new开辟内存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%96%E5%88%AB%E5%90%8D"><span class="toc-number">30.</span> <span class="toc-text">自定义类型与取别名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">31.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="toc-number">31.1.</span> <span class="toc-text">结构体定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">31.2.</span> <span class="toc-text">结构体的初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%94%AE%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">31.3.</span> <span class="toc-text">使用键值初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">31.4.</span> <span class="toc-text">匿名结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">31.5.</span> <span class="toc-text">结构体字段的可见性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">31.6.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%92%8C%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-number">31.7.</span> <span class="toc-text">方法和接收者</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95"><span class="toc-number">32.</span> <span class="toc-text">任意类型添加方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">33.</span> <span class="toc-text">包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%8C%85"><span class="toc-number">33.1.</span> <span class="toc-text">定义包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7-%E5%AF%B9%E5%A4%96%E5%8F%AF%E8%A7%81%E7%9A%84%E6%88%90%E5%91%98%E6%B3%A8%E6%84%8F%E8%A6%81%E5%86%99%E6%B3%A8%E9%87%8A"><span class="toc-number">33.2.</span> <span class="toc-text">可见性 对外可见的成员注意要写注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E5%AF%BC%E5%85%A5"><span class="toc-number">33.3.</span> <span class="toc-text">包的导入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E5%90%8D"><span class="toc-number">33.4.</span> <span class="toc-text">自定义包名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%BC%E5%85%A5%E5%8C%85"><span class="toc-number">33.5.</span> <span class="toc-text">匿名导入包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#init-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="toc-number">34.</span> <span class="toc-text">init()初始化函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#init-%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">35.</span> <span class="toc-text">init()函数执行顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E5%86%99init%E5%87%BD%E6%95%B0-%E7%9B%B8%E5%BD%93%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">36.</span> <span class="toc-text">重写init函数,相当于构造函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">37.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%98%AF%E4%B8%80%E7%A7%8D%E6%8A%BD%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">37.1.</span> <span class="toc-text">接口是一种抽象的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">37.2.</span> <span class="toc-text">接口的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">37.3.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85%E5%92%8C%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">37.4.</span> <span class="toc-text">值接收者和指针接收者实现接口的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97"><span class="toc-number">37.5.</span> <span class="toc-text">接口嵌套</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3"><span class="toc-number">37.6.</span> <span class="toc-text">空接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">37.7.</span> <span class="toc-text">空接口的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">37.8.</span> <span class="toc-text">类型断言</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">38.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#reflect%E5%8C%85"><span class="toc-number">38.1.</span> <span class="toc-text">reflect包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeOf"><span class="toc-number">38.2.</span> <span class="toc-text">TypeOf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-name%E5%92%8Ctype-kind"><span class="toc-number">38.3.</span> <span class="toc-text">type name和type kind</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ValueOf"><span class="toc-number">38.4.</span> <span class="toc-text">ValueOf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%AE%BE%E7%BD%AE%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC"><span class="toc-number">38.5.</span> <span class="toc-text">通过反射设置变量的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8D%E5%B0%84"><span class="toc-number">38.6.</span> <span class="toc-text">结构体反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%87%BD%E6%95%B0printMethod-s-interface-%E6%9D%A5%E9%81%8D%E5%8E%86%E6%89%93%E5%8D%B0s%E5%8C%85%E5%90%AB%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">38.7.</span> <span class="toc-text">编写函数printMethod(s interface{})来遍历打印s包含的方法。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">39.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#goroutine"><span class="toc-number">39.1.</span> <span class="toc-text">goroutine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GOMAXPROCS"><span class="toc-number">39.2.</span> <span class="toc-text">GOMAXPROCS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#channel%E7%B1%BB%E5%9E%8B"><span class="toc-number">40.</span> <span class="toc-text">channel类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">40.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAchannel"><span class="toc-number">40.2.</span> <span class="toc-text">创建channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#channel%E6%93%8D%E4%BD%9C"><span class="toc-number">40.3.</span> <span class="toc-text">channel操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E9%80%81"><span class="toc-number">40.4.</span> <span class="toc-text">发送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6"><span class="toc-number">40.5.</span> <span class="toc-text">接收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%97%AD"><span class="toc-number">40.6.</span> <span class="toc-text">关闭</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%BC%93%E5%86%B2%E7%9A%84%E9%80%9A%E9%81%93"><span class="toc-number">40.7.</span> <span class="toc-text">无缓冲的通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E7%BC%93%E5%86%B2%E7%9A%84%E9%80%9A%E9%81%93"><span class="toc-number">40.8.</span> <span class="toc-text">有缓冲的通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-range%E4%BB%8E%E9%80%9A%E9%81%93%E5%BE%AA%E7%8E%AF%E5%8F%96%E5%80%BC"><span class="toc-number">40.9.</span> <span class="toc-text">for range从通道循环取值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E9%80%9A%E9%81%93"><span class="toc-number">40.10.</span> <span class="toc-text">单向通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#worker-pool%EF%BC%88goroutine%E6%B1%A0%EF%BC%89"><span class="toc-number">40.11.</span> <span class="toc-text">worker pool（goroutine池）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">40.12.</span> <span class="toc-text">select多路复用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81"><span class="toc-number">41.</span> <span class="toc-text">并发安全和锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">41.1.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">41.2.</span> <span class="toc-text">读写互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-Once"><span class="toc-number">41.3.</span> <span class="toc-text">sync.Once</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-Map"><span class="toc-number">41.4.</span> <span class="toc-text">sync.Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">41.5.</span> <span class="toc-text">原子操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP%E9%80%9A%E4%BF%A1"><span class="toc-number">42.</span> <span class="toc-text">TCP通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">42.1.</span> <span class="toc-text">TCP服务端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">42.2.</span> <span class="toc-text">TCP客户端</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UDP%E9%80%9A%E4%BF%A1"><span class="toc-number">43.</span> <span class="toc-text">UDP通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">43.1.</span> <span class="toc-text">UDP服务端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">43.2.</span> <span class="toc-text">UDP客户端</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/qt-with-opencv/" title="Qt配置opencv环境"><img src="https://s1.ax1x.com/2020/08/02/ate2E6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qt配置opencv环境"/></a><div class="content"><a class="title" href="/qt-with-opencv/" title="Qt配置opencv环境">Qt配置opencv环境</a><time datetime="2020-08-02T10:22:51.000Z" title="发表于 2020-08-02 18:22:51">2020-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/git-used/" title="GIT使用笔记"><img src="https://s1.ax1x.com/2020/07/19/UWJuZR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GIT使用笔记"/></a><div class="content"><a class="title" href="/git-used/" title="GIT使用笔记">GIT使用笔记</a><time datetime="2020-07-19T10:29:59.000Z" title="发表于 2020-07-19 18:29:59">2020-07-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Qt-note/" title="Qt学习笔记"><img src="https://s1.ax1x.com/2020/07/19/UWJDW8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qt学习笔记"/></a><div class="content"><a class="title" href="/Qt-note/" title="Qt学习笔记">Qt学习笔记</a><time datetime="2020-07-19T09:38:50.000Z" title="发表于 2020-07-19 17:38:50">2020-07-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/spider-comic/" title="python爬取漫画网站"><img src="http://yanxuan.nosdn.127.net/bb8aaf99bd11f0eb934431477caecda6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="python爬取漫画网站"/></a><div class="content"><a class="title" href="/spider-comic/" title="python爬取漫画网站">python爬取漫画网站</a><time datetime="2020-05-27T05:58:41.000Z" title="发表于 2020-05-27 13:58:41">2020-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/spider-novels-thread/" title="python爬取小说多线程版本"><img src="http://yanxuan.nosdn.127.net/21a929d6d313be9954b494a502d99764.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="python爬取小说多线程版本"/></a><div class="content"><a class="title" href="/spider-novels-thread/" title="python爬取小说多线程版本">python爬取小说多线程版本</a><time datetime="2020-05-24T13:43:00.000Z" title="发表于 2020-05-24 21:43:00">2020-05-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 秋山澪</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>